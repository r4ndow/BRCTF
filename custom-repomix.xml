This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where comments have been removed, line numbers have been added.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Line numbers have been added to the beginning of each line
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
.repomixignore
build.gradle.kts
gradle.properties
gradle/wrapper/gradle-wrapper.jar
gradle/wrapper/gradle-wrapper.properties
gradlew.bat
justfile
libs/craftbukkit-1.8.8.jar
libs/holographicdisplays-api-3.0.0.jar
libs/holographicdisplays-core-3.0.0.jar
libs/ProtocolLib-4.7.0.jar
libs/spigot-1.8.8.jar
repomix.config.json
src/main/java/com/mcpvp/battle/Battle.java
src/main/java/com/mcpvp/battle/BattlePlugin.java
src/main/java/com/mcpvp/battle/BattlePreferences.java
src/main/java/com/mcpvp/battle/command/CapturesCommand.java
src/main/java/com/mcpvp/battle/command/FlagCommands.java
src/main/java/com/mcpvp/battle/command/KitCommand.java
src/main/java/com/mcpvp/battle/command/KitManagerCommands.java
src/main/java/com/mcpvp/battle/command/MapCommands.java
src/main/java/com/mcpvp/battle/command/QuickCommand.java
src/main/java/com/mcpvp/battle/command/QuickCommands.java
src/main/java/com/mcpvp/battle/command/RespawnCommand.java
src/main/java/com/mcpvp/battle/command/SwitchCommand.java
src/main/java/com/mcpvp/battle/command/TimerCommand.java
src/main/java/com/mcpvp/battle/command/YellCommand.java
src/main/java/com/mcpvp/battle/config/BattleCallout.java
src/main/java/com/mcpvp/battle/config/BattleGameConfig.java
src/main/java/com/mcpvp/battle/config/BattleTeamConfig.java
src/main/java/com/mcpvp/battle/map/BattleMapCategory.java
src/main/java/com/mcpvp/battle/map/BattleMapData.java
src/main/java/com/mcpvp/battle/map/BattleMapTester.java
src/main/java/com/mcpvp/battle/map/BattleWorldManager.java
src/main/java/com/mcpvp/battle/map/loader/BattleMapLoader.java
src/main/java/com/mcpvp/battle/map/loader/BattleMapMetadataLoader.java
src/main/java/com/mcpvp/battle/map/loader/BattleMapSignLoader.java
src/main/java/com/mcpvp/battle/map/manager/BattleMapManager.java
src/main/java/com/mcpvp/battle/map/manager/MergingMapManager.java
src/main/java/com/mcpvp/battle/map/repo/BattleMapSource.java
src/main/java/com/mcpvp/battle/map/repo/CentralMapSource.java
src/main/java/com/mcpvp/battle/map/repo/CustomMapSource.java
src/main/java/com/mcpvp/battle/match/BattleMatch.java
src/main/java/com/mcpvp/battle/match/BattleMatchManager.java
src/main/java/com/mcpvp/battle/match/BattleMatchStructureRestrictions.java
src/main/java/com/mcpvp/battle/match/BattleMatchTimer.java
src/main/java/com/mcpvp/battle/options/BattleOptions.java
src/main/java/com/mcpvp/battle/options/BattleOptionsInput.java
src/main/java/com/mcpvp/battle/options/BattleOptionsLoader.java
src/main/java/com/mcpvp/battle/role/Role.java
src/main/java/com/mcpvp/battle/role/RoleManager.java
src/main/java/com/mcpvp/battle/role/RoleObjectiveListener.java
src/main/java/com/mcpvp/battle/role/RolePreferenceGui.java
src/main/java/com/mcpvp/battle/scoreboard/BattleScoreboardListener.java
src/main/java/com/mcpvp/battle/scoreboard/BattleScoreboardManager.java
src/main/java/com/mcpvp/battle/team/BattleTeam.java
src/main/java/com/mcpvp/battle/team/BattleTeamManager.java
src/main/java/com/mcpvp/battle/util/BattleUtil.java
src/main/java/com/mcpvp/battle/util/EmptyGenerator.java
src/main/java/com/mcpvp/common/chat/C.java
src/main/java/com/mcpvp/common/chat/Colors.java
src/main/java/com/mcpvp/common/command/CommandUtil.java
src/main/java/com/mcpvp/common/command/EasyCommand.java
src/main/java/com/mcpvp/common/command/EasyCommandGroup.java
src/main/java/com/mcpvp/common/EasyLifecycle.java
src/main/java/com/mcpvp/common/event/EasyCancellableEvent.java
src/main/java/com/mcpvp/common/event/EasyEvent.java
src/main/java/com/mcpvp/common/event/EasyListener.java
src/main/java/com/mcpvp/common/event/EventUtil.java
src/main/java/com/mcpvp/common/event/TickEvent.java
src/main/java/com/mcpvp/common/InteractiveProjectile.java
src/main/java/com/mcpvp/common/JsonFile.java
src/main/java/com/mcpvp/common/kit/Kit.java
src/main/java/com/mcpvp/common/kit/KitAttemptSelectEvent.java
src/main/java/com/mcpvp/common/kit/KitDefinition.java
src/main/java/com/mcpvp/common/kit/KitInfo.java
src/main/java/com/mcpvp/common/kit/KitItem.java
src/main/java/com/mcpvp/common/kit/KitManager.java
src/main/java/com/mcpvp/common/kit/KitSelectedEvent.java
src/main/java/com/mcpvp/common/movement/CancelNextFallTask.java
src/main/java/com/mcpvp/common/movement/SpongeUtil.java
src/main/java/com/mcpvp/common/movement/VelocityManager.java
src/main/java/com/mcpvp/common/ParticlePacket.java
src/main/java/com/mcpvp/common/PluginContainer.java
src/main/java/com/mcpvp/common/preference/Preference.java
src/main/java/com/mcpvp/common/preference/PreferenceManager.java
src/main/java/com/mcpvp/common/shape/Cuboid.java
src/main/java/com/mcpvp/common/shape/Shape.java
src/main/java/com/mcpvp/common/structure/Structure.java
src/main/java/com/mcpvp/common/structure/StructureBlock.java
src/main/java/com/mcpvp/common/structure/StructureBuilder.java
src/main/java/com/mcpvp/common/structure/StructureManager.java
src/main/java/com/mcpvp/common/structure/StructureViolation.java
src/main/java/com/mcpvp/common/structure/StructureViolationChecker.java
src/main/java/com/mcpvp/common/task/DrainExpBarTask.java
src/main/java/com/mcpvp/common/task/EasyTask.java
src/main/java/com/mcpvp/common/task/ExpBarTask.java
src/main/java/com/mcpvp/common/task/FillExpBarTask.java
src/main/java/com/mcpvp/common/time/Duration.java
src/main/java/com/mcpvp/common/time/Expiration.java
src/main/java/com/mcpvp/common/util/BlockUtil.java
src/main/java/com/mcpvp/common/util/EffectUtil.java
src/main/java/com/mcpvp/common/util/EntityUtil.java
src/main/java/com/mcpvp/common/util/LocationUtil.java
src/main/java/com/mcpvp/common/util/LookUtil.java
src/main/java/com/mcpvp/common/util/nms/ActionbarUtil.java
src/main/java/com/mcpvp/common/util/nms/PacketUtil.java
src/main/java/com/mcpvp/common/util/nms/TitleUtil.java
src/main/java/com/mcpvp/common/util/PlayerUtil.java
src/main/java/com/mcpvp/common/util/ScoreboardUtil.java
src/main/java/com/mcpvp/common/visibility/PacketVisibilityManager.java
src/main/java/com/mcpvp/common/visibility/VanillaVisibilityManager.java
src/main/java/com/mcpvp/common/visibility/VisibilityManager.java
src/main/resources/plugin.yml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".repomixignore">
 1: README.md
 2: src/main/java/com/mcpvp/battle/chat
 3: src/main/java/com/mcpvp/battle/hud
 4: #src/main/java/com/mcpvp/battle/command/**
 5: src/main/java/com/mcpvp/battle/event/**
 6: src/main/java/com/mcpvp/battle/flag/**
 7: src/main/java/com/mcpvp/battle/game/**
 8: src/main/java/com/mcpvp/battle/kit/**
 9: src/main/java/com/mcpvp/battle/kits/**
10: #src/main/java/com/mcpvp/battle/map
11: #src/main/java/com/mcpvp/battle/match/**
12: #src/main/java/com/mcpvp/battle/scoreboard/**
13: src/main/java/com/mcpvp/common/item/**
14: #src/main/java/com/mcpvp/common/util/**
15: src/main/resources/maps.json
16: #src/main/resources/plugin.yml
</file>

<file path="gradle/wrapper/gradle-wrapper.properties">
1: distributionBase=GRADLE_USER_HOME
2: distributionPath=wrapper/dists
3: distributionUrl=https\://services.gradle.org/distributions/gradle-7.6.1-bin.zip
4: zipStoreBase=GRADLE_USER_HOME
5: zipStorePath=wrapper/dists
</file>

<file path="gradlew.bat">
 1: @rem
 2: @rem Copyright 2015 the original author or authors.
 3: @rem
 4: @rem Licensed under the Apache License, Version 2.0 (the "License");
 5: @rem you may not use this file except in compliance with the License.
 6: @rem You may obtain a copy of the License at
 7: @rem
 8: @rem      https://www.apache.org/licenses/LICENSE-2.0
 9: @rem
10: @rem Unless required by applicable law or agreed to in writing, software
11: @rem distributed under the License is distributed on an "AS IS" BASIS,
12: @rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13: @rem See the License for the specific language governing permissions and
14: @rem limitations under the License.
15: @rem
16: 
17: @if "%DEBUG%" == "" @echo off
18: @rem ##########################################################################
19: @rem
20: @rem  Gradle startup script for Windows
21: @rem
22: @rem ##########################################################################
23: 
24: @rem Set local scope for the variables with windows NT shell
25: if "%OS%"=="Windows_NT" setlocal
26: 
27: set DIRNAME=%~dp0
28: if "%DIRNAME%" == "" set DIRNAME=.
29: set APP_BASE_NAME=%~n0
30: set APP_HOME=%DIRNAME%
31: 
32: @rem Resolve any "." and ".." in APP_HOME to make it shorter.
33: for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi
34: 
35: @rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
36: set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"
37: 
38: @rem Find java.exe
39: if defined JAVA_HOME goto findJavaFromJavaHome
40: 
41: set JAVA_EXE=java.exe
42: %JAVA_EXE% -version >NUL 2>&1
43: if "%ERRORLEVEL%" == "0" goto execute
44: 
45: echo.
46: echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
47: echo.
48: echo Please set the JAVA_HOME variable in your environment to match the
49: echo location of your Java installation.
50: 
51: goto fail
52: 
53: :findJavaFromJavaHome
54: set JAVA_HOME=%JAVA_HOME:"=%
55: set JAVA_EXE=%JAVA_HOME%/bin/java.exe
56: 
57: if exist "%JAVA_EXE%" goto execute
58: 
59: echo.
60: echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
61: echo.
62: echo Please set the JAVA_HOME variable in your environment to match the
63: echo location of your Java installation.
64: 
65: goto fail
66: 
67: :execute
68: @rem Setup the command line
69: 
70: set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
71: 
72: 
73: @rem Execute Gradle
74: "%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*
75: 
76: :end
77: @rem End local scope for the variables with windows NT shell
78: if "%ERRORLEVEL%"=="0" goto mainEnd
79: 
80: :fail
81: rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
82: rem the _cmd.exe /c_ return code!
83: if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
84: exit /b 1
85: 
86: :mainEnd
87: if "%OS%"=="Windows_NT" endlocal
88: 
89: :omega
</file>

<file path="justfile">
1: build:
2: 	./gradlew shadowJar
</file>

<file path="repomix.config.json">
 1: {
 2:   "$schema": "https://repomix.com/schemas/latest/schema.json",
 3:   "input": {
 4:     "maxFileSize": 52428800
 5:   },
 6:   "output": {
 7:     "filePath": "custom-repomix.xml",
 8:     "style": "xml",
 9:     "parsableStyle": false,
10:     "fileSummary": true,
11:     "directoryStructure": true,
12:     "files": true,
13:     "removeComments": true,
14:     "removeEmptyLines": false,
15:     "compress": false,
16:     "topFilesLength": 10,
17:     "showLineNumbers": true,
18:     "truncateBase64": false,
19:     "copyToClipboard": true,
20:     "includeFullDirectoryStructure": false,
21:     "tokenCountTree": true,
22:     "git": {
23:       "sortByChanges": true,
24:       "sortByChangesMaxCommits": 100,
25:       "includeDiffs": false,
26:       "includeLogs": false,
27:       "includeLogsCount": 50
28:     }
29:   },
30:   "include": [],
31:   "ignore": {
32:     "useGitignore": true,
33:     "useDotIgnore": true,
34:     "useDefaultPatterns": true,
35:     "customPatterns": []
36:   },
37:   "security": {
38:     "enableSecurityCheck": true
39:   },
40:   "tokenCount": {
41:     "encoding": "o200k_base"
42:   }
43: }
</file>

<file path="src/main/java/com/mcpvp/battle/config/BattleCallout.java">
 1: package com.mcpvp.battle.config;
 2: 
 3: import lombok.AllArgsConstructor;
 4: import lombok.Data;
 5: import org.bukkit.Location;
 6: 
 7: @Data
 8: @AllArgsConstructor
 9: public class BattleCallout {
10: 
11:     private final Location location;
12:     private final BattleTeamConfig config;
13:     private final String text;
14: 
15: }
</file>

<file path="src/main/java/com/mcpvp/battle/config/BattleTeamConfig.java">
 1: package com.mcpvp.battle.config;
 2: 
 3: import lombok.Data;
 4: import lombok.RequiredArgsConstructor;
 5: import org.bukkit.Location;
 6: 
 7: 
 8: 
 9: 
10: @Data
11: @RequiredArgsConstructor
12: public class BattleTeamConfig {
13: 
14:     private final int id;
15:     private Location spawn;
16:     private Location flag;
17: 
18: }
</file>

<file path="src/main/java/com/mcpvp/battle/map/BattleMapData.java">
 1: package com.mcpvp.battle.map;
 2: 
 3: import lombok.AllArgsConstructor;
 4: import lombok.Builder;
 5: import lombok.Data;
 6: import lombok.extern.jackson.Jacksonized;
 7: 
 8: import java.time.LocalDateTime;
 9: import java.util.ArrayList;
10: import java.util.List;
11: 
12: @Data
13: @Builder(toBuilder = true)
14: @Jacksonized
15: @AllArgsConstructor
16: public class BattleMapData {
17: 
18: 
19: 
20: 
21:     private final int id;
22: 
23: 
24: 
25: 
26:     private final String name;
27: 
28: 
29: 
30: 
31:     private final String author;
32: 
33: 
34: 
35: 
36:     private final LocalDateTime created;
37: 
38: 
39: 
40: 
41: 
42:     private boolean functional;
43: 
44: 
45: 
46: 
47: 
48:     private final String file;
49: 
50: 
51: 
52: 
53:     private final String metadata;
54: 
55: 
56: 
57: 
58:     @Builder.Default
59:     BattleMapCategory category = BattleMapCategory.DEFAULT;
60: 
61: 
62: 
63: 
64:     @Builder.Default
65:     List<String> errors = new ArrayList<>();
66: 
67: }
</file>

<file path="src/main/java/com/mcpvp/battle/map/manager/BattleMapManager.java">
 1: package com.mcpvp.battle.map.manager;
 2: 
 3: import com.mcpvp.battle.map.BattleMapData;
 4: import com.mcpvp.battle.map.repo.BattleMapSource;
 5: 
 6: import java.io.File;
 7: import java.util.List;
 8: 
 9: 
10: 
11: 
12: public interface BattleMapManager {
13: 
14: 
15: 
16: 
17: 
18: 
19:     List<BattleMapData> getEnabled();
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27:     boolean isMap(int id);
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36:     List<Integer> pickMaps(int games);
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44:     BattleMapData loadMap(int id);
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52:     List<BattleMapData> loadMaps(int games);
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60:     File getWorldData(BattleMapData map);
61: 
62: 
63: 
64: 
65: 
66: 
67:     void setOverride(List<Integer> ids);
68: 
69: 
70: 
71: 
72:     void clearOverride();
73: 
74: 
75: 
76: 
77: 
78:     List<BattleMapData> getOverride();
79: 
80: }
</file>

<file path="src/main/java/com/mcpvp/battle/match/BattleMatchTimer.java">
 1: package com.mcpvp.battle.match;
 2: 
 3: import lombok.AllArgsConstructor;
 4: import lombok.Data;
 5: import lombok.NoArgsConstructor;
 6: 
 7: @Data
 8: @NoArgsConstructor
 9: @AllArgsConstructor
10: public class BattleMatchTimer {
11: 
12:     private int seconds = 60;
13:     private boolean paused = false;
14: 
15: }
</file>

<file path="src/main/java/com/mcpvp/battle/util/EmptyGenerator.java">
 1: package com.mcpvp.battle.util;
 2: 
 3: import org.bukkit.Location;
 4: import org.bukkit.World;
 5: import org.bukkit.block.Biome;
 6: import org.bukkit.generator.ChunkGenerator;
 7: 
 8: import java.util.Random;
 9: 
10: public class EmptyGenerator extends ChunkGenerator {
11: 
12:     @Override
13:     public byte[][] generateBlockSections(World world, Random random, int x, int z, BiomeGrid biomes) {
14:         for (int i = 0; i < 16; i++) {
15:             for (int k = 0; k < 16; k++) {
16:                 biomes.setBiome(i, k, Biome.PLAINS);
17:             }
18:         }
19:         return new byte[world.getMaxHeight() >> 4][];
20:     }
21: 
22:     @Override
23:     public boolean canSpawn(World world, int x, int z) {
24:         return true;
25:     }
26: 
27:     @Override
28:     public Location getFixedSpawnLocation(World world, Random random) {
29:         return new Location(world, 0, 64, 0);
30:     }
31: 
32: }
</file>

<file path="src/main/java/com/mcpvp/common/command/CommandUtil.java">
 1: package com.mcpvp.common.command;
 2: 
 3: import lombok.SneakyThrows;
 4: import org.bukkit.Bukkit;
 5: import org.bukkit.command.CommandMap;
 6: 
 7: import java.lang.reflect.Field;
 8: import java.util.Collection;
 9: import java.util.List;
10: 
11: public class CommandUtil {
12: 
13:     @SneakyThrows
14:     public static CommandMap getCommandMap() {
15:         Field mapField = Bukkit.getServer().getClass().getDeclaredField("commandMap");
16:         mapField.setAccessible(true);
17: 
18:         return (CommandMap) mapField.get(Bukkit.getServer());
19:     }
20: 
21:     public static List<String> partialMatches(Collection<String> list, String query) {
22:         return list.stream()
23:             .map(String::toLowerCase)
24:             .filter(string -> string.startsWith(query.toLowerCase()))
25:             .toList();
26:     }
27: }
</file>

<file path="src/main/java/com/mcpvp/common/event/EasyEvent.java">
 1: package com.mcpvp.common.event;
 2: 
 3: import org.bukkit.Bukkit;
 4: import org.bukkit.event.Event;
 5: import org.bukkit.event.HandlerList;
 6: 
 7: public class EasyEvent extends Event {
 8: 
 9:     private static final HandlerList handlers = new HandlerList();
10: 
11:     @Override
12:     public HandlerList getHandlers() {
13:         return handlers;
14:     }
15: 
16: 
17:     @SuppressWarnings("unused")
18:     public static HandlerList getHandlerList() {
19:         return handlers;
20:     }
21: 
22:     public void call() {
23:         Bukkit.getPluginManager().callEvent(this);
24:     }
25: 
26: }
</file>

<file path="src/main/java/com/mcpvp/common/event/EventUtil.java">
 1: package com.mcpvp.common.event;
 2: 
 3: import org.bukkit.event.block.Action;
 4: import org.bukkit.event.entity.EntityDamageEvent;
 5: import org.bukkit.event.player.PlayerInteractEvent;
 6: 
 7: import java.util.stream.Stream;
 8: 
 9: public class EventUtil {
10: 
11:     public static boolean isRightClick(PlayerInteractEvent event) {
12:         return event.getAction() == Action.RIGHT_CLICK_AIR || event.getAction() == Action.RIGHT_CLICK_BLOCK;
13:     }
14: 
15:     public static boolean isLeftClick(PlayerInteractEvent event) {
16:         return event.getAction() == Action.LEFT_CLICK_AIR || event.getAction() == Action.LEFT_CLICK_BLOCK;
17:     }
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26:     public static void setDamage(EntityDamageEvent event, double damage) {
27:         Stream.of(EntityDamageEvent.DamageModifier.values())
28:             .filter(event::isApplicable)
29:             .forEach(mod -> event.setDamage(mod, 0));
30: 
31:         event.setDamage(EntityDamageEvent.DamageModifier.BASE, damage);
32:     }
33: 
34: }
</file>

<file path="src/main/java/com/mcpvp/common/kit/KitDefinition.java">
 1: package com.mcpvp.common.kit;
 2: 
 3: import org.bukkit.entity.Player;
 4: import org.bukkit.plugin.Plugin;
 5: 
 6: public interface KitDefinition extends KitInfo {
 7: 
 8:     Kit create(Plugin plugin, Player player);
 9: 
10: }
</file>

<file path="src/main/java/com/mcpvp/common/kit/KitInfo.java">
1: package com.mcpvp.common.kit;
2: 
3: public interface KitInfo {
4: 
5:     String getName();
6: 
7: }
</file>

<file path="src/main/java/com/mcpvp/common/kit/KitSelectedEvent.java">
 1: package com.mcpvp.common.kit;
 2: 
 3: import com.mcpvp.common.event.EasyEvent;
 4: import lombok.Data;
 5: import lombok.EqualsAndHashCode;
 6: import lombok.RequiredArgsConstructor;
 7: import org.bukkit.entity.Player;
 8: 
 9: 
10: 
11: 
12: @Data
13: @EqualsAndHashCode(callSuper = false)
14: @RequiredArgsConstructor
15: public class KitSelectedEvent extends EasyEvent {
16: 
17:     private final Player player;
18:     private final KitDefinition kitDefinition;
19:     private final boolean respawn;
20: 
21: }
</file>

<file path="src/main/java/com/mcpvp/common/movement/SpongeUtil.java">
 1: package com.mcpvp.common.movement;
 2: 
 3: import org.bukkit.Material;
 4: import org.bukkit.block.Block;
 5: import org.bukkit.block.BlockFace;
 6: import org.bukkit.entity.Player;
 7: import org.bukkit.plugin.Plugin;
 8: import org.bukkit.util.Vector;
 9: 
10: public final class SpongeUtil {
11: 
12:     private SpongeUtil() {
13:     }
14: 
15:     public static void launch(Plugin plugin, Player player, Block block) {
16:         launch(plugin, player, block, null);
17:     }
18: 
19:     public static void launch(Plugin plugin, Player player, Block block, Runnable task) {
20:         Vector velocity = new Vector(0, getSpongeDepth(block), 0);
21:         velocity = velocity.add(new Vector(getSpongeDepth(block.getRelative(-1, -1, 0)), 0, 0));
22:         velocity = velocity.add(new Vector(-getSpongeDepth(block.getRelative(1, -1, 0)), 0, 0));
23:         velocity = velocity.add(new Vector(0, 0, getSpongeDepth(block.getRelative(0, -1, -1))));
24:         velocity = velocity.add(new Vector(0, 0, -getSpongeDepth(block.getRelative(0, -1, 1))));
25:         velocity = velocity.multiply(10);
26:         new VelocityManager(plugin, player, velocity, task);
27:     }
28: 
29:     private static int getSpongeDepth(Block block) {
30:         int depth = 0;
31:         while (block.getType() == Material.SPONGE) {
32:             depth++;
33:             if (block.getY() == 0 || depth > 10) {
34:                 break;
35:             }
36:             block = block.getRelative(BlockFace.DOWN);
37:         }
38:         return depth;
39:     }
40: }
</file>

<file path="src/main/java/com/mcpvp/common/PluginContainer.java">
 1: package com.mcpvp.common;
 2: 
 3: import org.bukkit.plugin.Plugin;
 4: 
 5: 
 6: 
 7: 
 8: public interface PluginContainer {
 9: 
10: 
11: 
12: 
13:     Plugin getPlugin();
14: 
15: }
</file>

<file path="src/main/java/com/mcpvp/common/structure/StructureViolation.java">
 1: package com.mcpvp.common.structure;
 2: 
 3: import lombok.Getter;
 4: import lombok.RequiredArgsConstructor;
 5: 
 6: @Getter
 7: @RequiredArgsConstructor
 8: public class StructureViolation {
 9: 
10: 
11: 
12: 
13:     private final String key;
14: 
15: 
16: 
17: 
18:     private final String message;
19: 
20: }
</file>

<file path="src/main/java/com/mcpvp/common/structure/StructureViolationChecker.java">
 1: package com.mcpvp.common.structure;
 2: 
 3: import org.bukkit.block.Block;
 4: 
 5: import java.util.Optional;
 6: 
 7: 
 8: 
 9: 
10: public interface StructureViolationChecker {
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18:     Optional<StructureViolation> check(Block block);
19: 
20: }
</file>

<file path="src/main/java/com/mcpvp/common/task/EasyTask.java">
 1: package com.mcpvp.common.task;
 2: 
 3: import org.bukkit.scheduler.BukkitRunnable;
 4: 
 5: public class EasyTask {
 6: 
 7: 
 8: 
 9: 
10: 
11: 
12: 
13: 
14:     public static BukkitRunnable of(EasyTaskRunner runner) {
15:         return new BukkitRunnable() {
16:             @Override
17:             public void run() {
18:                 runner.run(this::cancel);
19:             }
20:         };
21:     }
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29:     public static BukkitRunnable of(Runnable runnable) {
30:         return new BukkitRunnable() {
31:             @Override
32:             public void run() {
33:                 runnable.run();
34:             }
35:         };
36:     }
37: 
38:     public interface EasyTaskRunner {
39:         void run(EasyTaskReference reference);
40:     }
41: 
42:     public interface EasyTaskReference {
43: 
44: 
45: 
46:         void cancel();
47:     }
48: 
49: }
</file>

<file path="src/main/java/com/mcpvp/common/task/ExpBarTask.java">
 1: package com.mcpvp.common.task;
 2: 
 3: import org.bukkit.plugin.Plugin;
 4: import org.bukkit.scheduler.BukkitTask;
 5: 
 6: public sealed interface ExpBarTask extends Runnable permits DrainExpBarTask, FillExpBarTask {
 7: 
 8:     BukkitTask schedule(Plugin plugin);
 9: 
10: }
</file>

<file path="src/main/java/com/mcpvp/common/util/BlockUtil.java">
 1: package com.mcpvp.common.util;
 2: 
 3: import org.bukkit.block.Block;
 4: 
 5: import java.util.ArrayList;
 6: import java.util.List;
 7: 
 8: public class BlockUtil {
 9: 
10: 
11: 
12: 
13: 
14: 
15: 
16:     public static List<Block> getBlocksInRadius(Block center, int radius) {
17:         List<Block> blocks = new ArrayList<>();
18:         for (int x = -radius; x <= radius; x++) {
19:             for (int z = -radius; z <= radius; z++) {
20:                 for (int y = -radius; y <= radius; y++) {
21:                     Block block = center.getRelative(x, y, z);
22:                     if (center.getLocation().distance(block.getLocation()) <= radius) {
23:                         blocks.add(block);
24:                     }
25:                 }
26:             }
27:         }
28:         return blocks;
29:     }
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38:     public static List<Block> getBlocksInRadius(Block center, int radius, int height) {
39:         List<Block> blocks = new ArrayList<>();
40:         for (int x = -radius; x <= radius; x++) {
41:             for (int z = -radius; z <= radius; z++) {
42:                 for (int y = -height; y <= height; y++) {
43:                     Block block = center.getRelative(x, y, z);
44:                     if (center.getLocation().distance(block.getLocation()) <= radius) {
45:                         blocks.add(block);
46:                     }
47:                 }
48:             }
49:         }
50:         return blocks;
51:     }
52: 
53: }
</file>

<file path="src/main/java/com/mcpvp/common/util/EffectUtil.java">
  1: package com.mcpvp.common.util;
  2: 
  3: import com.mcpvp.common.ParticlePacket;
  4: import com.mcpvp.common.task.EasyTask;
  5: import net.minecraft.server.v1_8_R3.PacketPlayOutWorldBorder;
  6: import net.minecraft.server.v1_8_R3.WorldBorder;
  7: import net.minecraft.server.v1_8_R3.WorldServer;
  8: import org.bukkit.Color;
  9: import org.bukkit.FireworkEffect;
 10: import org.bukkit.Location;
 11: import org.bukkit.World;
 12: import org.bukkit.block.Block;
 13: import org.bukkit.craftbukkit.v1_8_R3.CraftWorld;
 14: import org.bukkit.craftbukkit.v1_8_R3.entity.CraftEntity;
 15: import org.bukkit.craftbukkit.v1_8_R3.entity.CraftFirework;
 16: import org.bukkit.entity.Entity;
 17: import org.bukkit.entity.Firework;
 18: import org.bukkit.entity.Player;
 19: import org.bukkit.entity.Projectile;
 20: import org.bukkit.inventory.meta.FireworkMeta;
 21: import org.bukkit.scheduler.BukkitRunnable;
 22: 
 23: import java.util.ArrayList;
 24: import java.util.List;
 25: 
 26: public class EffectUtil {
 27: 
 28:     public static void fakeLightning(Location location) {
 29:         World world = location.getWorld();
 30:         Block block = world.getHighestBlockAt(location.getBlockX(), location.getBlockZ());
 31:         if (block != null) {
 32:             location = location.clone();
 33:             location.setY(Math.min(world.getMaxHeight(), block.getY()));
 34:             world.strikeLightningEffect(location);
 35:         }
 36:     }
 37: 
 38:     public static BukkitRunnable trail(Entity entity, ParticlePacket particle) {
 39:         return EasyTask.of(task -> {
 40:             if (entity.isDead()) {
 41:                 task.cancel();
 42:                 return;
 43:             }
 44: 
 45:             if (entity instanceof Projectile p && p.isOnGround()) {
 46:                 task.cancel();
 47:                 return;
 48:             }
 49: 
 50:             particle.at(entity.getLocation()).send();
 51:         });
 52:     }
 53: 
 54:     public static BukkitRunnable colorTrail(Entity entity, Color color) {
 55:         return trail(entity, ParticlePacket.colored(color));
 56:     }
 57: 
 58:     public static void sendBorderEffect(Player player) {
 59:         org.bukkit.craftbukkit.v1_8_R3.entity.CraftPlayer cp = (org.bukkit.craftbukkit.v1_8_R3.entity.CraftPlayer) player;
 60: 
 61:         net.minecraft.server.v1_8_R3.WorldBorder w = new WorldBorder();
 62:         w.setSize(100000);
 63:         w.setCenter(player.getLocation().getX(), player.getLocation().getZ());
 64:         w.setWarningDistance(1000000);
 65:         cp.getHandle().playerConnection.sendPacket(
 66:             new PacketPlayOutWorldBorder(w, PacketPlayOutWorldBorder.EnumWorldBorderAction.INITIALIZE)
 67:         );
 68:     }
 69: 
 70:     public static void resetBorderEffect(Player player) {
 71:         org.bukkit.craftbukkit.v1_8_R3.entity.CraftPlayer cp = (org.bukkit.craftbukkit.v1_8_R3.entity.CraftPlayer) player;
 72: 
 73:         WorldBorder ww = new WorldBorder();
 74:         ww.setSize(30_000_000);
 75:         ww.setCenter(player.getLocation().getX(), player.getLocation().getZ());
 76:         cp.getHandle().playerConnection.sendPacket(
 77:             new PacketPlayOutWorldBorder(ww, PacketPlayOutWorldBorder.EnumWorldBorderAction.INITIALIZE)
 78:         );
 79:     }
 80: 
 81:     public static void sendInstantFirework(FireworkEffect effect, Location location) {
 82:         Firework firework = location.getWorld().spawn(location, Firework.class);
 83:         FireworkMeta meta = firework.getFireworkMeta();
 84:         meta.clearEffects();
 85:         meta.addEffect(effect);
 86:         firework.setFireworkMeta(meta);
 87:         ((CraftFirework) firework).getHandle().expectedLifespan = 1;
 88:         WorldServer w = ((CraftWorld) location.getWorld()).getHandle();
 89:         w.broadcastEntityEffect(((CraftEntity) firework).getHandle(), (byte) 17);
 90:     }
 91: 
 92:     public static List<Location> getParticleRing(Location center, int count, double radius) {
 93:         List<Location> locations = new ArrayList<>();
 94:         for (int i = 0; i < count; i++) {
 95: 
 96:             Location loc = center.clone().add(
 97:                 radius * Math.cos(2 * Math.PI / count * i) + 0.5,
 98:                 1.25,
 99:                 radius * Math.sin(2 * Math.PI / count * i) + 0.5
100:             );
101:             locations.add(loc);
102:         }
103:         return locations;
104:     }
105: 
106:     public static List<Location> getParticleSphere(Location center, int count, double radius) {
107:         double phi = Math.PI * (Math.sqrt(5) - 1);
108:         List<Location> locations = new ArrayList<>();
109: 
110:         for (int i = 0; i < count; i++) {
111:             double y = 1.0 - (i / (count - 1.0)) * 2.0;
112:             double r = Math.sqrt(1 - y * y);
113:             double theta = phi * i;
114: 
115:             double x = Math.cos(theta) * r;
116:             double z = Math.sin(theta) * r;
117: 
118: 
119:             Location loc = center.clone().add(
120:                 x * radius, y * radius, z * radius
121:             );
122:             locations.add(loc);
123:         }
124:         return locations;
125:     }
126: 
127: }
</file>

<file path="src/main/java/com/mcpvp/common/util/EntityUtil.java">
 1: package com.mcpvp.common.util;
 2: 
 3: import org.bukkit.Location;
 4: import org.bukkit.entity.Entity;
 5: 
 6: import java.util.List;
 7: 
 8: public class EntityUtil {
 9: 
10:     public static final double GRAVITY = -0.0784000015258789;
11: 
12:     public static <T extends Entity> List<T> getNearbyEntities(
13:         Location location, Class<T> type, double distance
14:     ) {
15:         return getNearbyEntities(location, type, distance, distance, distance);
16:     }
17: 
18:     public static <T extends Entity> List<T> getNearbyEntities(
19:         Location location, Class<T> type, double x, double y, double z
20:     ) {
21: 
22:         return location.getWorld().getNearbyEntities(location, x, y, z).stream()
23:             .filter(e -> type.isAssignableFrom(e.getClass()))
24:             .map(e -> (T) e)
25:             .toList();
26:     }
27: 
28:     public static boolean isOnGround(Entity entity) {
29: 
30: 
31:         return entity.getVelocity().getY() == GRAVITY && entity.isOnGround();
32:     }
33: 
34: }
</file>

<file path="src/main/java/com/mcpvp/common/util/LocationUtil.java">
 1: package com.mcpvp.common.util;
 2: 
 3: import org.bukkit.Location;
 4: import org.bukkit.util.Vector;
 5: 
 6: import java.util.ArrayList;
 7: import java.util.List;
 8: 
 9: public class LocationUtil {
10: 
11:     public static List<Location> trace(Location from, Location to, int count) {
12:         List<Location> locations = new ArrayList<>();
13:         Location progress = from.clone();
14:         Vector movement = to.toVector().subtract(from.toVector()).multiply(1d / count);
15:         for (int i = 0; i < count; i++) {
16:             progress.add(movement);
17:             locations.add(progress.clone());
18:         }
19:         return locations;
20:     }
21: 
22: }
</file>

<file path="src/main/java/com/mcpvp/common/visibility/PacketVisibilityManager.java">
1: 
</file>

<file path="src/main/java/com/mcpvp/common/visibility/VanillaVisibilityManager.java">
 1: package com.mcpvp.common.visibility;
 2: 
 3: import org.bukkit.entity.Player;
 4: 
 5: public class VanillaVisibilityManager implements VisibilityManager {
 6: 
 7:     @Override
 8:     public void hide(Player observer, Player target) {
 9:         observer.hidePlayer(target);
10:     }
11: 
12:     @Override
13:     public void show(Player observer, Player target) {
14:         observer.showPlayer(target);
15:     }
16: 
17:     @Override
18:     public boolean canSee(Player observer, Player target) {
19:         return observer.canSee(target);
20:     }
21: 
22: }
</file>

<file path="src/main/java/com/mcpvp/common/visibility/VisibilityManager.java">
 1: package com.mcpvp.common.visibility;
 2: 
 3: import org.bukkit.entity.Player;
 4: 
 5: public interface VisibilityManager {
 6: 
 7:     default void init() {
 8:     }
 9: 
10: 
11: 
12: 
13: 
14: 
15: 
16:     void hide(Player observer, Player target);
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24:     void show(Player observer, Player target);
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33:     boolean canSee(Player observer, Player target);
34: 
35: }
</file>

<file path="gradle.properties">
1: org.gradle.java.home=C:\\Program Files\\Eclipse Adoptium\\jdk-17.0.16.8-hotspot
</file>

<file path="src/main/java/com/mcpvp/battle/command/QuickCommands.java">
 1: package com.mcpvp.battle.command;
 2: 
 3: import com.mcpvp.battle.Battle;
 4: 
 5: public class QuickCommands {
 6: 
 7:     public static void registerAll(Battle battle) {
 8:         new QuickCommand(battle, "gg", "Good Game!").all().register();
 9:         new QuickCommand(battle, "gl", "Good luck!").all().register();
10:         new QuickCommand(battle, "md", "Medic!").loc().register();
11:         new QuickCommand(battle, "ty", "Thank you!").register();
12:         new QuickCommand(battle, "np", "No problem!").register();
13:         new QuickCommand(battle, "yw", "You're welcome!").register();
14:         new QuickCommand(battle, "c", "Careful!").register();
15:         new QuickCommand(battle, "s", "Sorry!").register();
16:         new QuickCommand(battle, "gj", "Good job!").register();
17:         new QuickCommand(battle, "d", "Defend, please!").register();
18:         new QuickCommand(battle, "omw", "On my way!").register();
19:         new QuickCommand(battle, "o", "Offend, please!").register();
20:         new QuickCommand(battle, "rp", "Recover, please!").register();
21:         new QuickCommand(battle, "h", "Help me!").loc().register();
22:         new QuickCommand(battle, "fm", "Follow me!").loc().register();
23:         new QuickCommand(battle, "wo", "Watch out!").loc().register();
24:         new QuickCommand(battle, "b", "Buffs, please!").loc().register();
25:         new QuickCommand(battle, "in", "Incoming!").loc().register();
26:         new QuickCommand(battle, "hf", "Have fun!").all().register();
27:         new QuickCommand(battle, "nw", "No worries!").register();
28:         new QuickCommand(battle, "wp", "Well played!").all().register();
29:         new QuickCommand(battle, "glhf", "Good luck, have fun!").all().register();
30:         new QuickCommand(battle, "belltower", "we need a fleet of soldiers to conquer the belltower").register();
31:         new QuickCommand(battle, "rmbr", "redslime may be responsible").all().register();
32:         new QuickCommand(battle, "ctf", "Capture the flag, please!").register();
33:         new QuickCommand(battle, "ns", "Nice shot!").all().register();
34:         new QuickCommand(battle, "lgt", "Let's go team!").register();
35:         new QuickCommand(battle, "bye", "bye.").register();
36:         new QuickCommand(battle, "ok", "ok.").register();
37:         new QuickCommand(battle, "udwm", "u don wan mess").register();
38:         new QuickCommand(battle, "ily", "I love you").register();
39:         new QuickCommand(battle, "bn", "Blame Nom!").all().register();
40:         new QuickCommand(battle, "mb", "My bad!").register();
41: 
42:         new QuickCommand(battle, "boa", "Boa!").register();
43:         new QuickCommand(battle, "valeu", "Valeu!").register();
44:         new QuickCommand(battle, "dr", "Drope a bandeira, por favor!").loc().register();
45:         new QuickCommand(battle, "se", "Segure a bandeira, por favor!").loc().register();
46:         new QuickCommand(battle, "re", "Retornem a bandeira, por favor!").loc().register();
47:     }
48: 
49: }
</file>

<file path="src/main/java/com/mcpvp/battle/map/BattleMapCategory.java">
 1: package com.mcpvp.battle.map;
 2: 
 3: import lombok.AllArgsConstructor;
 4: import lombok.Getter;
 5: 
 6: @Getter
 7: @AllArgsConstructor
 8: public enum BattleMapCategory {
 9:     DEFAULT("Unclassified CTF Maps"),
10:     MCPVP("Maps from MCPVP era"),
11:     CTF2015("Maps from 2015"),
12:     CTF2016("Maps from 2016"),
13:     CTF2017("Maps from 2017"),
14:     CTF2018("Maps from 2018"),
15:     CTF2019("Maps from 2019"),
16:     CTF2020("Maps from 2020"),
17:     WAVE1("Maps from Wave I"),
18:     WAVE2("Maps from Wave II"),
19:     WAVE3("Maps from Wave III"),
20:     WAVE4("Maps from Wave IV"),
21:     WAVE5("Maps from Wave V"),
22:     WAVE6("Maps from Wave VI"),
23:     WAVE7("Maps from Wave VII"),
24:     WAVE8("Maps from Wave VIII"),
25:     WAVE9("Maps from Wave IX"),
26:     WAVE10("Maps from Wave X"),
27:     WAVE11("Maps from Wave XI"),
28:     WAVE12("Maps from Wave XII"),
29:     WAVE13("Maps from Wave XIII"),
30:     WAVE14("Maps from Wave XIV"),
31:     WAVE15("Maps from Wave XV"),
32:     WAVE16("Maps from Wave XVI"),
33:     WAVE17("Maps from Wave XVII"),
34:     WAVE18("Maps from Wave XVIII"),
35:     WAVE19("Maps from Wave XIX"),
36:     WAVE20("Maps from Wave XX"),
37:     WAVE10TEST("Rejected Maps from Wave X"),
38:     WAVE11TEST("Rejected Maps from Wave XI"),
39:     WAVE12TEST("Rejected Maps from Wave XII"),
40:     WAVE13TEST("Rejected Maps from Wave XIII"),
41:     WAVE14TEST("Rejected Maps from Wave XIV"),
42:     WAVE15TEST("Rejected Maps from Wave XV"),
43:     WAVE16TEST("Rejected Maps from Wave XVI"),
44:     WAVE17TEST("Rejected Maps from Wave XVII"),
45:     WAVE18TEST("Rejected Maps from Wave XVIII"),
46:     WAVE19TEST("Rejected Maps from Wave XIX"),
47:     WAVE20TEST("Rejected Maps from Wave XX"),
48:     VAULT("Maps from MCPVP's Vault"),
49:     SPECIAL("Special Gamemodes/Events"),
50:     SPOOKY("Spooky Halloween Maps"),
51:     CHRISTMAS("Festive Christmas Maps"),
52:     LOVE("Valentine Day Maps"),
53:     EASTER("Easter Maps"),
54:     ZONES("Zone Control Maps"),
55:     DELIVERY("Delivery Maps"),
56:     FOURTEAMS("4-Teams CTF Maps"),
57:     XD("April's Fool Maps"),
58:     MLG("MLG Maps"),
59:     VARIATION("Variation Maps"),
60:     ORIGINAL("Original Maps from 2011"),
61:     UNRELEASED("Unreleased Maps"),
62:     MEME("Various Memes");
63: 
64:     private final String desc;
65: 
66: }
</file>

<file path="src/main/java/com/mcpvp/battle/map/loader/BattleMapLoader.java">
 1: package com.mcpvp.battle.map.loader;
 2: 
 3: import com.mcpvp.battle.config.BattleGameConfig;
 4: import com.mcpvp.battle.map.BattleMapData;
 5: import org.bukkit.World;
 6: 
 7: public interface BattleMapLoader {
 8: 
 9:     BattleGameConfig parse(BattleMapData map, World world);
10: 
11: }
</file>

<file path="src/main/java/com/mcpvp/battle/map/loader/BattleMapSignLoader.java">
  1: package com.mcpvp.battle.map.loader;
  2: 
  3: import com.mcpvp.battle.config.BattleCallout;
  4: import com.mcpvp.battle.config.BattleGameConfig;
  5: import com.mcpvp.battle.config.BattleTeamConfig;
  6: import com.mcpvp.battle.map.BattleMapData;
  7: import com.mcpvp.common.util.LookUtil;
  8: import lombok.AllArgsConstructor;
  9: import lombok.Data;
 10: import lombok.Getter;
 11: import lombok.extern.log4j.Log4j2;
 12: import org.bukkit.*;
 13: import org.bukkit.block.Block;
 14: import org.bukkit.block.Sign;
 15: import org.bukkit.material.Directional;
 16: 
 17: import java.util.ArrayList;
 18: import java.util.Arrays;
 19: import java.util.List;
 20: import java.util.Optional;
 21: import java.util.function.Predicate;
 22: import java.util.regex.Pattern;
 23: import java.util.stream.Stream;
 24: 
 25: @Log4j2
 26: public class BattleMapSignLoader implements BattleMapLoader {
 27: 
 28:     private static final String RE_SIGN = Pattern.quote("{{") + "(.*)" + Pattern.quote("}}");
 29:     private static final String RE_VAL_SIGN = Pattern.quote("{{") + "(.*)=(.*)" + Pattern.quote("}}");
 30:     private static final String RE_TEAM_SIGN = Pattern.quote("{{") + "(.*) (.*)" + Pattern.quote("}}");
 31:     private static final String RE_CALLOUT_SIGN = Pattern.quote("{{") + "callout\\s?(\\d)?" + Pattern.quote("}}");
 32: 
 33:     public sealed interface MapSign permits SimpleMapSign, ValueMapSign, TeamMapSign, CalloutSign {
 34:         Block getBlock();
 35:     }
 36: 
 37:     @Data
 38:     @Getter
 39:     @AllArgsConstructor
 40:     public static final class SimpleMapSign implements MapSign {
 41:         private final Block block;
 42:         private final String text;
 43:     }
 44: 
 45:     @Data
 46:     @Getter
 47:     @AllArgsConstructor
 48:     public static final class ValueMapSign implements MapSign {
 49:         private final Block block;
 50:         private final String key;
 51:         private final String value;
 52:     }
 53: 
 54:     @Data
 55:     @Getter
 56:     @AllArgsConstructor
 57:     public static final class TeamMapSign implements MapSign {
 58:         private final Block block;
 59:         private final Integer team;
 60:         private final String text;
 61:     }
 62: 
 63: 
 64: 
 65: 
 66: 
 67: 
 68: 
 69: 
 70: 
 71: 
 72: 
 73: 
 74: 
 75: 
 76:     @Data
 77:     @Getter
 78:     @AllArgsConstructor
 79:     public static final class CalloutSign implements MapSign {
 80:         private final Block block;
 81:         private final Integer team;
 82:         private final String text;
 83:     }
 84: 
 85:     @Override
 86:     public BattleGameConfig parse(BattleMapData map, World world) {
 87:         BattleGameConfig builder = new BattleGameConfig();
 88:         builder.getTeamConfigs().add(new BattleTeamConfig(1));
 89:         builder.getTeamConfigs().add(new BattleTeamConfig(2));
 90: 
 91: 
 92: 
 93:         Location assumedCenter = world.getSpawnLocation();
 94:         List<ChunkSnapshot> chunks = this.getChunkSnapshotsAround(assumedCenter, 16);
 95:         chunks.forEach(cs -> this.highlightChunk(cs, world));
 96:         List<MapSign> signs = this.getAllMapSigns(chunks);
 97: 
 98:         if (signs.isEmpty()) {
 99:             throw new IllegalStateException(
100:                 "No signs were found within 16 chunks of the map's world spawn. " +
101:                 "This usually indicates that the spawn set on the map is incorrect and needs to be relocated. " +
102:                 "The current spawn is set at: (x=%s, y=%s, z=%s).".formatted(
103:                     world.getSpawnLocation().getX(), world.getSpawnLocation().getY(), world.getSpawnLocation().getZ()
104:                 ));
105:         }
106: 
107: 
108:         Optional<MapSign> spawnBox = signs
109:             .stream()
110:             .filter(ms -> ms instanceof SimpleMapSign sms && sms.getText().equals("spawn_box"))
111:             .findAny();
112:         Location foundCenter = spawnBox.map(ms -> ms.getBlock().getLocation()).orElse(assumedCenter);
113:         boolean spawnChanged = foundCenter.getBlockX() != assumedCenter.getBlockX() || foundCenter.getBlockZ() != assumedCenter.getBlockZ();
114: 
115:         builder.setSpawn(this.center(foundCenter));
116: 
117:         if (spawnChanged) {
118:             log.info("New spawn location found, re-loading chunks");
119:             chunks = this.getChunkSnapshotsAround(foundCenter, 16);
120:             signs = this.getAllMapSigns(chunks);
121:         }
122: 
123:         this.loadSignsIntoConfig(builder, signs);
124: 
125:         signs.forEach(sign ->
126:             sign.getBlock().setType(Material.AIR)
127:         );
128: 
129:         return builder;
130:     }
131: 
132:     private void loadSignsIntoConfig(
133:         BattleGameConfig builder, List<MapSign> signs
134:     ) {
135:         for (MapSign sign : signs) {
136:             if (sign instanceof TeamMapSign teamSign) {
137:                 this.loadTeamSign(builder, teamSign);
138:             } else if (sign instanceof ValueMapSign valueSign) {
139:                 this.loadValueSign(builder, valueSign);
140:             } else if (sign instanceof SimpleMapSign simpleSign) {
141:                 this.loadSimpleSign(builder, simpleSign);
142:             } else if (sign instanceof CalloutSign calloutSign) {
143:                 this.loadCalloutSign(builder, calloutSign);
144:             }
145:         }
146:     }
147: 
148:     private void loadSimpleSign(BattleGameConfig builder, SimpleMapSign sign) {
149:         switch (sign.getText()) {
150:             case "restrict" -> builder.getRestricted().add(sign.getBlock().getLocation());
151:             case "spawn_box" -> builder.setSpawn(sign.getBlock().getLocation());
152:             default -> log.warn("Unknown simple config given: {}", sign);
153:         }
154:     }
155: 
156:     private void loadValueSign(BattleGameConfig builder, ValueMapSign sign) {
157:         switch (sign.getKey()) {
158:             case "caps" -> builder.setCaps(Integer.parseInt(sign.getValue()));
159:             case "time" -> builder.setTime(Integer.parseInt(sign.getValue()));
160:             default -> log.warn("Unknown value config given: {}", sign);
161:         }
162:     }
163: 
164:     private void loadTeamSign(BattleGameConfig builder, TeamMapSign sign) {
165:         BattleTeamConfig teamConfig = builder.getTeamConfig(sign.getTeam());
166:         Location loc = sign.getBlock().getLocation();
167: 
168:         switch (sign.getText()) {
169:             case "spawn" -> {
170:                 teamConfig.setSpawn(this.center(loc));
171:                 builder.getCallouts().add(new BattleCallout(this.center(loc), teamConfig, "spawn"));
172:             }
173:             case "flag" -> {
174:                 teamConfig.setFlag(this.center(loc));
175:                 builder.getCallouts().add(new BattleCallout(this.center(loc), teamConfig, "flag"));
176:             }
177:             default -> log.warn("Unknown team config given: {}", sign);
178:         }
179:     }
180: 
181:     private void loadCalloutSign(BattleGameConfig builder, CalloutSign sign) {
182:         if (sign.getTeam() == null) {
183:             builder.getCallouts().add(new BattleCallout(sign.getBlock().getLocation(), null, sign.getText()));
184:         } else {
185:             BattleTeamConfig config = builder.getTeamConfig(sign.getTeam());
186:             builder.getCallouts().add(new BattleCallout(sign.getBlock().getLocation(), config, sign.getText()));
187:         }
188:     }
189: 
190:     private List<MapSign> getAllMapSigns(List<ChunkSnapshot> chunks) {
191:         return chunks.stream().flatMap(this::findSignBlocks).distinct().flatMap(b -> {
192:             if (!(b.getState() instanceof Sign sign)) {
193:                 return Stream.empty();
194:             }
195:             log.info("Found sign to parse at {} with text: {}", b.getLocation(), Arrays.toString(sign.getLines()));
196:             return this.parseMapSign(b, sign).stream();
197:         }).toList();
198:     }
199: 
200:     private List<MapSign> parseMapSign(Block block, Sign sign) {
201:         List<MapSign> found = new ArrayList<>();
202: 
203:         for (String line : sign.getLines()) {
204:             if (line.isBlank()) {
205:                 continue;
206:             }
207: 
208:             if (line.matches(RE_VAL_SIGN)) {
209:                 found.add(new ValueMapSign(block, line.replaceAll(RE_VAL_SIGN, "$1"), line.replaceAll(RE_VAL_SIGN, "$2")));
210:             } else if (line.matches(RE_CALLOUT_SIGN)) {
211:                 String teamId = line.replaceAll(RE_CALLOUT_SIGN, "$1");
212:                 if (teamId.isBlank()) {
213:                     found.add(new CalloutSign(block, null, sign.getLine(1)));
214:                 } else {
215:                     found.add(new CalloutSign(block, Integer.parseInt(teamId), sign.getLine(1)));
216:                 }
217:             } else if (line.matches(RE_TEAM_SIGN)) {
218:                 found.add(new TeamMapSign(block, Integer.parseInt(line.replaceAll(RE_TEAM_SIGN, "$2")), line.replaceAll(RE_TEAM_SIGN, "$1")));
219:             } else if (line.matches(RE_SIGN)) {
220:                 found.add(new SimpleMapSign(block, line.replaceAll(RE_SIGN, "$1")));
221:             }
222:         }
223: 
224:         return found;
225:     }
226: 
227:     private Stream<Block> findSignBlocks(ChunkSnapshot snapshot) {
228:         return this.findBlocks(snapshot, m -> m == Material.SIGN_POST).stream().distinct();
229:     }
230: 
231:     @SuppressWarnings("deprecation")
232:     private List<Block> findBlocks(ChunkSnapshot chunk, Predicate<Material> filter) {
233:         List<Block> result = new ArrayList<>();
234: 
235:         for (int x = 0; x != 16; x++)
236:             for (int z = 0; z != 16; z++)
237:                 for (int y = 0; y != 256; y++) {
238:                     int absX = chunk.getX() * 16 + x;
239:                     int absZ = chunk.getZ() * 16 + z;
240:                     Material m = Material.getMaterial(chunk.getBlockTypeId(x, y, z));
241:                     if (filter.test(m)) {
242:                         result.add(new Location(Bukkit.getWorld(chunk.getWorldName()), absX, y, absZ).getBlock());
243:                     }
244:                 }
245: 
246:         return result;
247:     }
248: 
249:     private List<ChunkSnapshot> getChunkSnapshotsAround(Location center, int radius) {
250:         World world = center.getWorld();
251:         int cX = center.getChunk().getX();
252:         int cZ = center.getChunk().getZ();
253:         List<ChunkSnapshot> chunkSnapshots = new ArrayList<>();
254:         for (int x = 0; x < radius; x++) {
255:             for (int z = 0; z < radius; z++) {
256:                 chunkSnapshots.add(world.getChunkAt(cX + x, cZ + z).getChunkSnapshot());
257:                 chunkSnapshots.add(world.getChunkAt(cX - x, cZ + z).getChunkSnapshot());
258:                 chunkSnapshots.add(world.getChunkAt(cX + x, cZ - z).getChunkSnapshot());
259:                 chunkSnapshots.add(world.getChunkAt(cX - x, cZ - z).getChunkSnapshot());
260:             }
261:         }
262:         return chunkSnapshots;
263:     }
264: 
265:     private void highlightChunk(ChunkSnapshot snapshot, World world) {
266: 
267:     }
268: 
269:     private Location center(Location loc) {
270:         if (loc.getBlock().getState().getData() instanceof Directional) {
271:             loc = this.getSignLocation(loc);
272:         }
273:         return loc.clone().add(0.5, 0, 0.5);
274:     }
275: 
276:     private Location getSignLocation(Location sign) {
277:         Directional dir = (Directional) sign.getBlock().getState().getData();
278:         Location targ = sign.getBlock().getRelative(dir.getFacing()).getLocation();
279:         return LookUtil.lookAt(sign, targ);
280:     }
281: 
282: }
</file>

<file path="src/main/java/com/mcpvp/battle/map/repo/BattleMapSource.java">
 1: package com.mcpvp.battle.map.repo;
 2: 
 3: import com.fasterxml.jackson.databind.ObjectMapper;
 4: import com.mcpvp.battle.map.BattleMapData;
 5: import com.mcpvp.battle.options.BattleOptionsInput;
 6: 
 7: import java.io.File;
 8: import java.util.List;
 9: 
10: 
11: 
12: 
13: public interface BattleMapSource {
14: 
15:     static BattleMapSource from(
16:         ObjectMapper objectMapper,
17:         BattleOptionsInput.MapSourceOptions source
18:     ) {
19:         if (source instanceof BattleOptionsInput.CentralMapSourceOptions cms) {
20:             return new CentralMapSource(objectMapper, cms);
21:         } else if (source instanceof BattleOptionsInput.CustomMapSourceOptions cms) {
22:             return new CustomMapSource(objectMapper, cms);
23:         } else {
24:             throw new IllegalArgumentException();
25:         }
26:     }
27: 
28: 
29: 
30: 
31:     void init();
32: 
33: 
34: 
35: 
36: 
37: 
38:     List<BattleMapData> getAll();
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46:     File getWorldData(BattleMapData map);
47: 
48: 
49: 
50: 
51: 
52: 
53:     default List<BattleMapData> getFunctional() {
54:         return this.getAll().stream().filter(BattleMapData::isFunctional).toList();
55:     }
56: 
57: }
</file>

<file path="src/main/java/com/mcpvp/battle/map/repo/CentralMapSource.java">
  1: package com.mcpvp.battle.map.repo;
  2: 
  3: import com.fasterxml.jackson.core.type.TypeReference;
  4: import com.fasterxml.jackson.databind.ObjectMapper;
  5: import com.mcpvp.battle.map.BattleMapData;
  6: import com.mcpvp.battle.options.BattleOptionsInput;
  7: import lombok.RequiredArgsConstructor;
  8: import lombok.extern.log4j.Log4j2;
  9: import org.apache.commons.io.FileUtils;
 10: import org.apache.commons.io.IOUtils;
 11: 
 12: import java.io.File;
 13: import java.io.IOException;
 14: import java.io.InputStream;
 15: import java.nio.charset.Charset;
 16: import java.util.ArrayList;
 17: import java.util.List;
 18: import java.util.Objects;
 19: 
 20: @Log4j2
 21: @RequiredArgsConstructor
 22: public class CentralMapSource implements BattleMapSource {
 23: 
 24:     private final ObjectMapper mapper;
 25:     private final BattleOptionsInput.CentralMapSourceOptions mapOptions;
 26:     private final List<BattleMapData> mapData = new ArrayList<>();
 27: 
 28:     @Override
 29:     public void init() {
 30:         File mapsDir = new File(this.mapOptions.getDir());
 31:         if (!mapsDir.exists()) {
 32:             throw new IllegalStateException("Maps directory does not exist: " + mapsDir);
 33:         }
 34: 
 35:         String mapsJson = this.loadMapsJson();
 36: 
 37:         try {
 38:             this.mapData.addAll(this.mapper.readValue(
 39:                 mapsJson, new TypeReference<List<BattleMapData>>() {
 40:                 }
 41:             ));
 42:         } catch (IOException e) {
 43:             throw new RuntimeException("Failed to read maps.json", e);
 44:         }
 45: 
 46:         this.check();
 47:     }
 48: 
 49:     private String loadMapsJson() {
 50:         String json = null;
 51: 
 52: 
 53:         File configured = new File(this.mapOptions.getJson());
 54:         if (configured.exists()) {
 55:             try {
 56:                 return Objects.requireNonNull(FileUtils.readFileToString(configured));
 57:             } catch (IOException e) {
 58:                 log.warn("Failed to read custom maps.json at {}", this.mapOptions.getJson(), e);
 59:             }
 60:         } else {
 61:             log.warn("Given a custom maps.json that does not exist, expected at {}", configured.getAbsoluteFile());
 62:         }
 63: 
 64: 
 65:         try (InputStream included = this.getClass().getResourceAsStream("/maps.json")) {
 66:             try {
 67:                 json = IOUtils.toString(Objects.requireNonNull(included), Charset.defaultCharset());
 68:             } catch (IOException e) {
 69:                 log.warn("Failed to read included maps.json", e);
 70:             }
 71:         } catch (IOException e) {
 72:             throw new RuntimeException(e);
 73:         }
 74: 
 75:         if (json == null) {
 76:             throw new RuntimeException("Could not load maps.json");
 77:         }
 78: 
 79:         return json;
 80:     }
 81: 
 82: 
 83: 
 84: 
 85:     private void check() {
 86:         if (this.mapData.isEmpty()) {
 87:             throw new IllegalStateException("No map data found");
 88:         }
 89: 
 90:         this.mapData.forEach(data -> {
 91:             File mapData = new File(this.mapOptions.getDir(), data.getFile());
 92: 
 93:             if (!mapData.exists()) {
 94:                 log.warn("Map file was not found. Expected at: {}", mapData);
 95:                 data.setFunctional(false);
 96:             }
 97:         });
 98:     }
 99: 
100:     @Override
101:     public List<BattleMapData> getAll() {
102:         return this.mapData;
103:     }
104: 
105:     @Override
106:     public File getWorldData(BattleMapData map) {
107:         return new File(this.mapOptions.getDir(), map.getFile());
108:     }
109: 
110: }
</file>

<file path="src/main/java/com/mcpvp/battle/map/repo/CustomMapSource.java">
 1: package com.mcpvp.battle.map.repo;
 2: 
 3: import com.fasterxml.jackson.databind.ObjectMapper;
 4: import com.mcpvp.battle.map.BattleMapData;
 5: import com.mcpvp.battle.options.BattleOptionsInput;
 6: import lombok.RequiredArgsConstructor;
 7: 
 8: import java.io.File;
 9: import java.io.IOException;
10: import java.util.ArrayList;
11: import java.util.List;
12: import java.util.Objects;
13: 
14: 
15: 
16: 
17: 
18: 
19: @RequiredArgsConstructor
20: public class CustomMapSource implements BattleMapSource {
21: 
22:     private final ObjectMapper mapper;
23:     private final BattleOptionsInput.CustomMapSourceOptions options;
24: 
25:     @Override
26:     public void init() {
27:         if (!new File(this.options.getDir()).exists()) {
28:             throw new IllegalArgumentException("Expected a custom map repository, but it does not exist at path %s".formatted(
29:                 new File(this.options.getDir()).getAbsolutePath()
30:             ));
31:         }
32:     }
33: 
34:     @Override
35:     public List<BattleMapData> getAll() {
36:         List<BattleMapData> maps = new ArrayList<>();
37:         for (File map : Objects.requireNonNull(new File(this.options.getDir()).listFiles())) {
38:             File data = new File(map, "ctf.json");
39:             if (!data.exists()) {
40:                 continue;
41:             }
42: 
43:             try {
44:                 maps.add(this.mapper.readValue(data, BattleMapData.class));
45:             } catch (IOException e) {
46:                 throw new RuntimeException("Failed to read map data for folder %s".formatted(map.getAbsolutePath()), e);
47:             }
48:         }
49: 
50:         return maps;
51:     }
52: 
53:     @Override
54:     public File getWorldData(BattleMapData map) {
55:         return new File(this.options.getDir(), map.getFile());
56:     }
57: 
58: }
</file>

<file path="src/main/java/com/mcpvp/battle/match/BattleMatchManager.java">
 1: package com.mcpvp.battle.match;
 2: 
 3: import com.mcpvp.battle.Battle;
 4: import com.mcpvp.battle.BattlePlugin;
 5: import com.mcpvp.battle.game.BattleGame;
 6: import com.mcpvp.battle.game.BattleGameManager;
 7: import com.mcpvp.battle.map.BattleMapData;
 8: import com.mcpvp.battle.map.manager.BattleMapManager;
 9: import lombok.AllArgsConstructor;
10: import lombok.extern.log4j.Log4j2;
11: 
12: import java.util.ArrayList;
13: import java.util.List;
14: import java.util.Objects;
15: 
16: @Log4j2
17: @AllArgsConstructor
18: public class BattleMatchManager {
19: 
20:     private final BattlePlugin plugin;
21:     private final Battle battle;
22:     private final BattleGameManager gameLoader;
23:     private final BattleMapManager mapManager;
24: 
25:     public BattleMatch create() {
26:         List<BattleGame> games = new ArrayList<>();
27:         List<BattleMapData> maps = this.selectMaps();
28:         for (int i = 0; i < maps.size(); i++) {
29:             games.add(this.gameLoader.create(maps.get(i), this.mapManager.getWorldData(maps.get(i)), i));
30:         }
31: 
32:         return new BattleMatch(this.plugin, this.battle, games);
33:     }
34: 
35:     private List<BattleMapData> selectMaps() {
36:         if (this.mapManager.getOverride() != null && !this.mapManager.getOverride().isEmpty()) {
37:             List<BattleMapData> maps = this.mapManager.getOverride().stream()
38:                 .map(BattleMapData::getId)
39:                 .peek(id -> {
40:                     if (!this.mapManager.isMap(id) || this.mapManager.loadMap(id) == null) {
41:                         log.warn("Map ID {} is not enabled and will be ignored", id);
42:                     }
43:                 })
44:                 .filter(this.mapManager::isMap)
45:                 .map(this.mapManager::loadMap)
46:                 .filter(Objects::nonNull)
47:                 .toList();
48:             this.mapManager.clearOverride();
49:             return maps;
50:         }
51: 
52:         return this.mapManager.loadMaps(this.plugin.getBattle().getOptions().getMatch().getGames());
53:     }
54: 
55: }
</file>

<file path="src/main/java/com/mcpvp/battle/match/BattleMatchStructureRestrictions.java">
 1: package com.mcpvp.battle.match;
 2: 
 3: import com.mcpvp.common.structure.StructureManager;
 4: import com.mcpvp.common.structure.StructureViolation;
 5: import com.mcpvp.common.util.BlockUtil;
 6: import org.bukkit.Material;
 7: 
 8: import java.util.List;
 9: import java.util.Optional;
10: 
11: public class BattleMatchStructureRestrictions {
12: 
13:     public static final String IN_SPAWN = "IN_SPAWN";
14:     public static final String NEAR_SPAWN = "NEAR_SPAWN";
15:     public static final String NEAR_RESTRICTED = "NEAR_RESTRICTED";
16:     public static final String NEAR_FLAG = "NEAR_FLAG";
17:     public static final String IN_FLAG = "IN_FLAG";
18:     public static final String NEAR_PLAYER = "NEAR_PLAYER";
19: 
20:     private static final List<Material> RESTRICT_NEARBY = List.of(
21:         Material.PISTON_MOVING_PIECE, Material.MONSTER_EGGS, Material.BARRIER
22:     );
23:     private static final int SPAWN_RANGE = 10;
24:     private static final int FLAG_RANGE = 10;
25:     private static final int NEARBY_RANGE = 3;
26:     private static final double PLAYER_RANGE = 1.31;
27: 
28:     public static void register(BattleMatch match, StructureManager structureManager) {
29:         structureManager.registerChecker((block) -> {
30:             if (match.getCurrentGame().getTeamManager().getTeams().stream().anyMatch(bt ->
31:                 bt.isInSpawn(block.getLocation()))
32:             ) {
33:                 return Optional.of(new StructureViolation(IN_SPAWN, "You can't place this in spawn"));
34:             }
35:             return Optional.empty();
36:         });
37: 
38:         structureManager.registerChecker((block) -> {
39:             if (match.getCurrentGame().getTeamManager().getTeams().stream().anyMatch(bt ->
40:                 block.getLocation().distance(bt.getConfig().getSpawn()) <= SPAWN_RANGE)
41:             ) {
42:                 return Optional.of(new StructureViolation(NEAR_SPAWN, "You can't place this near spawn"));
43:             }
44:             return Optional.empty();
45:         });
46: 
47:         structureManager.registerChecker((block) -> {
48:             if (match.getCurrentGame().getTeamManager().getTeams().stream().anyMatch(bt ->
49:                 block.equals(bt.getFlag().getHome().getBlock())
50:             )) {
51:                 return Optional.of(new StructureViolation(IN_FLAG, "You can't place this on the flag"));
52:             }
53:             return Optional.empty();
54:         });
55: 
56:         structureManager.registerChecker((block) -> {
57:             if (match.getCurrentGame().getTeamManager().getTeams().stream().anyMatch(bt ->
58:                 block.getLocation().distance(bt.getFlag().getHome()) <= FLAG_RANGE)
59:             ) {
60:                 return Optional.of(new StructureViolation(NEAR_FLAG, "You can't place this near the flag"));
61:             }
62:             return Optional.empty();
63:         });
64: 
65:         structureManager.registerChecker((block) -> {
66:             if (BlockUtil.getBlocksInRadius(block, NEARBY_RANGE).stream().anyMatch(nearby ->
67:                 match.getCurrentGame().getConfig().getRestricted().contains(nearby.getLocation())
68:                     || RESTRICT_NEARBY.contains(nearby.getType())
69:             )) {
70:                 return Optional.of(new StructureViolation(NEAR_RESTRICTED, "Building is prohibited in this area"));
71:             }
72:             return Optional.empty();
73:         });
74: 
75:         structureManager.registerChecker((block) -> {
76:             if (match.getCurrentGame().getParticipants().stream().anyMatch(player ->
77:                 player.getLocation().distance(block.getLocation()) <= PLAYER_RANGE
78:             )) {
79:                 return Optional.of(new StructureViolation(NEAR_PLAYER, "Someone is in the way"));
80:             }
81:             return Optional.empty();
82:         });
83:     }
84: 
85: }
</file>

<file path="src/main/java/com/mcpvp/battle/options/BattleOptions.java">
 1: package com.mcpvp.battle.options;
 2: 
 3: import com.mcpvp.battle.BattlePlugin;
 4: import lombok.AllArgsConstructor;
 5: import lombok.Getter;
 6: import lombok.experimental.Delegate;
 7: 
 8: import java.io.IOException;
 9: import java.util.function.Consumer;
10: 
11: @Getter
12: @AllArgsConstructor
13: public class BattleOptions {
14: 
15: 
16: 
17: 
18:     @Delegate
19:     private final BattleOptionsInput input;
20:     private final BattlePlugin plugin;
21:     private final BattleOptionsLoader loader;
22: 
23:     public BattleOptions(BattlePlugin plugin, BattleOptionsLoader loader) throws IOException {
24:         this.plugin = plugin;
25:         this.loader = loader;
26:         this.input = loader.read();
27:     }
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35:     public void edit(Consumer<BattleOptionsInput> consumer) throws IOException {
36:         consumer.accept(this.input);
37:         this.loader.save(this.input);
38:     }
39: 
40: }
</file>

<file path="src/main/java/com/mcpvp/battle/options/BattleOptionsLoader.java">
 1: package com.mcpvp.battle.options;
 2: 
 3: import com.fasterxml.jackson.core.type.TypeReference;
 4: import com.fasterxml.jackson.databind.ObjectMapper;
 5: import com.mcpvp.battle.BattlePlugin;
 6: import com.mcpvp.common.JsonFile;
 7: import lombok.experimental.Delegate;
 8: import lombok.extern.log4j.Log4j2;
 9: 
10: import java.io.File;
11: 
12: 
13: 
14: 
15: @Log4j2
16: public class BattleOptionsLoader {
17: 
18:     @Delegate
19:     private final JsonFile<BattleOptionsInput> file;
20: 
21:     public BattleOptionsLoader(
22:         BattlePlugin plugin,
23:         ObjectMapper mapper
24:     ) {
25:         this.file = new JsonFile<>(
26:             new File(plugin.getDataFolder(), "config.json"),
27:             mapper,
28:             new TypeReference<>() {},
29:             () -> BattleOptionsInput.builder().build()
30:         );
31:     }
32: 
33: }
</file>

<file path="src/main/java/com/mcpvp/battle/role/Role.java">
 1: package com.mcpvp.battle.role;
 2: 
 3: public enum Role {
 4:     ATTACK("A"),
 5:     DEFENSE("D");
 6: 
 7:     private final String code;
 8: 
 9:     Role(String code) {
10:         this.code = code;
11:     }
12: 
13:     public String getCode() {
14:         return this.code;
15:     }
16: }
</file>

<file path="src/main/java/com/mcpvp/battle/role/RoleManager.java">
  1: package com.mcpvp.battle.role;
  2: 
  3: import com.mcpvp.battle.Battle;
  4: import com.mcpvp.battle.BattlePreferences;
  5: import com.mcpvp.battle.team.BattleTeam;
  6: import com.mcpvp.common.EasyLifecycle;
  7: import com.mcpvp.common.chat.C;
  8: import com.mcpvp.common.event.EasyListener;
  9: import com.mcpvp.common.preference.PreferenceManager;
 10: import com.mcpvp.battle.event.PlayerJoinTeamEvent;
 11: import com.mcpvp.battle.event.PlayerParticipateEvent;
 12: import com.mcpvp.battle.event.PlayerResignEvent;
 13: import lombok.Getter;
 14: import lombok.RequiredArgsConstructor;
 15: import org.bukkit.entity.Player;
 16: import org.bukkit.event.EventHandler;
 17: import org.bukkit.plugin.Plugin;
 18: 
 19: import java.util.Map;
 20: import java.util.UUID;
 21: import java.util.concurrent.ConcurrentHashMap;
 22: 
 23: 
 24: 
 25: 
 26: 
 27: @Getter
 28: @RequiredArgsConstructor
 29: public class RoleManager extends EasyLifecycle implements EasyListener {
 30: 
 31:     private final Plugin plugin;
 32:     private final Battle battle;
 33:     private final PreferenceManager preferenceManager;
 34: 
 35: 
 36:     private final Map<UUID, Role> roles = new ConcurrentHashMap<>();
 37: 
 38: 
 39:     private final Map<UUID, String> lastObjectiveAnnouncement = new ConcurrentHashMap<>();
 40: 
 41:     public void init() {
 42:         this.attach((EasyListener) this);
 43:     }
 44: 
 45:     @Override
 46:     public Plugin getPlugin() {
 47:         return this.plugin;
 48:     }
 49: 
 50:     public Role getRole(Player player) {
 51:         return this.roles.get(player.getUniqueId());
 52:     }
 53: 
 54:     public void setRole(Player player, Role role, boolean persist) {
 55:         UUID id = player.getUniqueId();
 56: 
 57:         if (role == null) {
 58:             this.roles.remove(id);
 59:         } else {
 60:             this.roles.put(id, role);
 61:         }
 62: 
 63:         if (persist) {
 64:             this.preferenceManager.store(player, BattlePreferences.ROLE, role);
 65:         }
 66: 
 67:         this.updateTabName(player);
 68: 
 69:     }
 70: 
 71: 
 72: 
 73: 
 74:     public void loadRole(Player player) {
 75:         this.preferenceManager
 76:                 .find(player, BattlePreferences.ROLE)
 77:                 .ifPresent(role -> {
 78:                     this.roles.put(player.getUniqueId(), role);
 79:                     this.updateTabName(player);
 80:                 });
 81:     }
 82: 
 83: 
 84: 
 85: 
 86:     public void updateTabName(Player player) {
 87:         BattleTeam team = this.battle.getGame().getTeamManager().getTeam(player);
 88:         String baseColor = team != null ? team.getColor().getChatString() : C.WHITE;
 89: 
 90:         Role role = this.getRole(player);
 91:         String tag = "";
 92: 
 93:         if (role == Role.ATTACK) {
 94:             tag = C.YELLOW + " [A]";
 95:         } else if (role == Role.DEFENSE) {
 96:             tag = C.AQUA + " [D]";
 97:         }
 98: 
 99:         player.setPlayerListName(baseColor + player.getName() + C.GRAY + tag);
100:     }
101: 
102:     /**
103:      * Computes the plain objective text for the sidebar, without colors or "Objective:" prefix.
104:      *
105:      * Defense role:
106:      * - Flag at base -> "Protect the flag"
107:      * - Flag stolen/dropped -> "Recover the flag"
108:      *
109:      * Attack role:
110:      * - You carry enemy flag -> "Capture the flag"
111:      * - Teammate carries enemy flag -> "Help the carrier"
112:      * - Enemy flag at base or dropped -> "Steal the flag"
113:      */
114:     public String computeObjectiveText(Player player) {
115:         Role role = this.getRole(player);
116:         if (role == null) {
117:             return null;
118:         }
119: 
120:         var teamManager = this.battle.getGame().getTeamManager();
121:         BattleTeam myTeam = teamManager.getTeam(player);
122:         if (myTeam == null) {
123:             return null;
124:         }
125: 
126: 
127:         BattleTeam enemy = teamManager.getTeams().stream()
128:                 .filter(t -> t != myTeam)
129:                 .findFirst()
130:                 .orElse(null);
131: 
132:         if (enemy == null) {
133:             return null;
134:         }
135: 
136:         if (role == Role.DEFENSE) {
137:             var flag = myTeam.getFlag();
138: 
139:             if (flag.isHome()) {
140:                 return "Defenda a bandeira!";
141:             }
142: 
143:             if (flag.getCarrier() != null &&
144:                     teamManager.getTeam(flag.getCarrier()) == enemy) {
145: 
146:                 return "Recupere a bandeira!";
147:             }
148: 
149:             if (flag.isDropped()) {
150:                 return "Recupere a bandeira!";
151:             }
152: 
153: 
154:             return "Defenda a bandeira!";
155:         }
156: 
157:         if (role == Role.ATTACK) {
158:             var flag = enemy.getFlag();
159: 
160: 
161:             if (flag.getCarrier() != null && flag.getCarrier().equals(player)) {
162:                 return "Capture a bandeira!";
163:             }
164: 
165: 
166:             if (flag.getCarrier() != null &&
167:                     teamManager.getTeam(flag.getCarrier()) == myTeam) {
168:                 return "Ajude o portador!";
169:             }
170: 
171: 
172:             if (flag.isHome() || flag.isDropped()) {
173:                 return "Roube a bandeira!";
174:             }
175: 
176: 
177:             return "Roube a bandeira!";
178:         }
179: 
180:         return null;
181:     }
182: 
183: 
184: 
185: 
186: 
187:     public void checkAndAnnounceObjective(Player player) {
188:         String text = this.computeObjectiveText(player);
189:         if (text == null) {
190:             return;
191:         }
192: 
193:         String line = C.WHITE + "Objective: " + C.R + text;
194: 
195:         UUID id = player.getUniqueId();
196:         String old = this.lastObjectiveAnnouncement.get(id);
197:         if (!line.equals(old)) {
198:             this.lastObjectiveAnnouncement.put(id, line);
199:             player.sendMessage(line);
200:         }
201:     }
202: 
203: 
204: 
205:     @EventHandler
206:     public void onParticipate(PlayerParticipateEvent event) {
207:         this.loadRole(event.getPlayer());
208:         this.updateTabName(event.getPlayer());
209: 
210:     }
211: 
212:     @EventHandler
213:     public void onResign(PlayerResignEvent event) {
214:         UUID id = event.getPlayer().getUniqueId();
215:         this.roles.remove(id);
216:         this.lastObjectiveAnnouncement.remove(id);
217:     }
218: 
219:     @EventHandler
220:     public void onJoinTeam(PlayerJoinTeamEvent event) {
221:         this.updateTabName(event.getPlayer());
222: 
223:     }
224: }
</file>

<file path="src/main/java/com/mcpvp/battle/role/RoleObjectiveListener.java">
 1: package com.mcpvp.battle.role;
 2: 
 3: import com.mcpvp.battle.Battle;
 4: import com.mcpvp.battle.event.FlagCaptureEvent;
 5: import com.mcpvp.battle.event.FlagDropEvent;
 6: import com.mcpvp.battle.event.FlagRecoverEvent;
 7: import com.mcpvp.battle.event.FlagStealEvent;
 8: import com.mcpvp.battle.event.PlayerParticipateEvent;
 9: import com.mcpvp.common.event.EasyListener;
10: import lombok.RequiredArgsConstructor;
11: import org.bukkit.entity.Player;
12: import org.bukkit.event.EventHandler;
13: import org.bukkit.plugin.Plugin;
14: 
15: 
16: 
17: 
18: @RequiredArgsConstructor
19: public class RoleObjectiveListener implements EasyListener {
20: 
21:     private final Plugin plugin;
22:     private final Battle battle;
23:     private final RoleManager roleManager;
24: 
25:     public void init() {
26:         this.register();
27:     }
28: 
29:     @Override
30:     public Plugin getPlugin() {
31:         return this.plugin;
32:     }
33: 
34:     private void updateAllParticipants() {
35:         for (Player player : this.battle.getGame().getParticipants()) {
36: 
37:         }
38:     }
39: 
40:     @EventHandler
41:     public void onFlagSteal(FlagStealEvent event) {
42:         this.updateAllParticipants();
43:     }
44: 
45:     @EventHandler
46:     public void onFlagDrop(FlagDropEvent event) {
47:         this.updateAllParticipants();
48:     }
49: 
50:     @EventHandler
51:     public void onFlagRecover(FlagRecoverEvent event) {
52:         this.updateAllParticipants();
53:     }
54: 
55:     @EventHandler
56:     public void onFlagCapture(FlagCaptureEvent event) {
57:         this.updateAllParticipants();
58:     }
59: 
60:     @EventHandler
61:     public void onParticipate(PlayerParticipateEvent event) {
62: 
63:     }
64: }
</file>

<file path="src/main/java/com/mcpvp/battle/role/RolePreferenceGui.java">
  1: package com.mcpvp.battle.role;
  2: 
  3: import com.mcpvp.battle.Battle;
  4: import com.mcpvp.common.chat.C;
  5: import com.mcpvp.common.event.EasyListener;
  6: import com.mcpvp.common.item.ItemBuilder;
  7: import lombok.RequiredArgsConstructor;
  8: import org.bukkit.Bukkit;
  9: import org.bukkit.Material;
 10: import org.bukkit.Sound;
 11: import org.bukkit.enchantments.Enchantment;
 12: import org.bukkit.entity.Player;
 13: import org.bukkit.event.EventHandler;
 14: import org.bukkit.event.inventory.InventoryClickEvent;
 15: import org.bukkit.inventory.Inventory;
 16: import org.bukkit.inventory.InventoryHolder;
 17: import org.bukkit.inventory.ItemFlag;
 18: import org.bukkit.inventory.ItemStack;
 19: import org.bukkit.plugin.Plugin;
 20: 
 21: 
 22: 
 23: 
 24: @RequiredArgsConstructor
 25: public class RolePreferenceGui implements EasyListener, InventoryHolder {
 26: 
 27:     private static final String TITLE = "Escolha uma funo:";
 28:     private static final int ATTACK_SLOT = 2;
 29:     private static final int DEFENSE_SLOT = 6;
 30: 
 31:     private final Plugin plugin;
 32:     private final Battle battle;
 33:     private final RoleManager roleManager;
 34: 
 35:     public void init() {
 36:         this.register();
 37:     }
 38: 
 39:     @Override
 40:     public Plugin getPlugin() {
 41:         return this.plugin;
 42:     }
 43: 
 44:     @Override
 45:     public Inventory getInventory() {
 46:         Inventory inv = Bukkit.createInventory(this, 9, TITLE);
 47: 
 48:         ItemStack attack = ItemBuilder.of(Material.GOLD_SWORD)
 49:                 .name(C.YELLOW + "ATAQUE")
 50:                 .desc("Ajude a capturar a bandeira inimiga!", 40)
 51:                 .enchant(Enchantment.DURABILITY, 10, true)
 52:                 .flag(ItemFlag.HIDE_ATTRIBUTES)
 53:                 .flag(ItemFlag.HIDE_ENCHANTS)
 54:                 .build();
 55: 
 56: 
 57:         ItemStack defense = ItemBuilder.of(Material.DIAMOND_CHESTPLATE)
 58:                 .name(C.AQUA + "DEFESA")
 59:                 .desc("Ajude a defender e recuperar a sua bandeira!", 40)
 60:                 .enchant(Enchantment.DURABILITY, 10, true)
 61:                 .flag(ItemFlag.HIDE_ENCHANTS)
 62:                 .build();
 63: 
 64:         inv.setItem(ATTACK_SLOT, attack);
 65:         inv.setItem(DEFENSE_SLOT, defense);
 66: 
 67:         return inv;
 68:     }
 69: 
 70:     public void open(Player player) {
 71:         player.openInventory(this.getInventory());
 72:         player.playSound(player.getEyeLocation(), Sound.CLICK, 1.0f, 1.0f);
 73:     }
 74: 
 75: 
 76: 
 77: 
 78:     public void openForAllParticipants() {
 79:         this.battle.getGame().getParticipants().forEach(this::open);
 80:     }
 81: 
 82:     @EventHandler
 83:     public void onClick(InventoryClickEvent event) {
 84:         if (!(event.getWhoClicked() instanceof Player player)) {
 85:             return;
 86:         }
 87: 
 88:         if (event.getInventory().getHolder() != this) {
 89:             return;
 90:         }
 91: 
 92:         event.setCancelled(true);
 93: 
 94:         int slot = event.getRawSlot();
 95:         Role chosen = null;
 96: 
 97:         if (slot == ATTACK_SLOT) {
 98:             chosen = Role.ATTACK;
 99:             player.playSound(player.getEyeLocation(), Sound.CLICK, 1.0f, 1.0f);
100: 
101:         } else if (slot == DEFENSE_SLOT) {
102:             chosen = Role.DEFENSE;
103:             player.playSound(player.getEyeLocation(), Sound.CLICK, 1.0f, 1.0f);
104:         }
105: 
106:         if (chosen == null) {
107:             return;
108:         }
109: 
110:         this.roleManager.setRole(player, chosen, true);
111:         player.closeInventory();
112:         player.sendMessage(
113:                 C.cmdPass() + "Selected " +
114:                         C.WHITE + chosen.name() + C.GRAY +
115:                         " as your role."
116:         );
117:     }
118: }
</file>

<file path="src/main/java/com/mcpvp/battle/scoreboard/BattleScoreboardListener.java">
 1: package com.mcpvp.battle.scoreboard;
 2: 
 3: import com.mcpvp.battle.Battle;
 4: import com.mcpvp.battle.BattlePlugin;
 5: import com.mcpvp.battle.event.PlayerJoinTeamEvent;
 6: import com.mcpvp.common.event.EasyListener;
 7: import com.mcpvp.common.event.TickEvent;
 8: import lombok.AllArgsConstructor;
 9: import lombok.Getter;
10: import org.bukkit.Bukkit;
11: import org.bukkit.event.EventHandler;
12: import org.bukkit.event.EventPriority;
13: import org.bukkit.event.player.PlayerJoinEvent;
14: 
15: @Getter
16: @AllArgsConstructor
17: public class BattleScoreboardListener implements EasyListener {
18: 
19:     private final BattlePlugin plugin;
20:     private final Battle battle;
21:     private final BattleScoreboardManager scoreboardManager;
22: 
23: 
24:     @EventHandler(priority = EventPriority.LOW)
25:     public void onPlayerJoin(PlayerJoinEvent event) {
26:         event.getPlayer().setScoreboard(this.scoreboardManager.create());
27:     }
28: 
29:     @EventHandler
30:     public void onJoinTeam(PlayerJoinTeamEvent event) {
31:         this.scoreboardManager.setTeam(event.getPlayer(), event.getTeam());
32:     }
33: 
34:     @EventHandler
35:     public void onTick(TickEvent event) {
36:         Bukkit.getOnlinePlayers().forEach(this.scoreboardManager::refresh);
37:     }
38: 
39: }
</file>

<file path="src/main/java/com/mcpvp/battle/util/BattleUtil.java">
 1: package com.mcpvp.battle.util;
 2: 
 3: import com.mcpvp.common.item.ItemBuilder;
 4: import org.bukkit.DyeColor;
 5: import org.bukkit.Location;
 6: import org.bukkit.Material;
 7: import org.bukkit.entity.Item;
 8: import org.bukkit.inventory.ItemStack;
 9: import org.bukkit.util.Vector;
10: 
11: public class BattleUtil {
12: 
13:     public static Item spawnWool(Location location, ItemStack item) {
14:         Location l = location.clone().add(0, .5, 0);
15:         Item i = location.getWorld().dropItem(l, item);
16:         i.setVelocity(new Vector(0, 0.15, 0));
17:         return i;
18:     }
19: 
20:     public static ItemStack getColoredWool(DyeColor color) {
21:         return ItemBuilder.of(Material.WOOL).color(color).build();
22:     }
23: 
24:     public static ItemStack getColoredBanner(DyeColor color) {
25: 
26:         return new ItemStack(Material.BANNER, 1, color.getDyeData());
27:     }
28: 
29: }
</file>

<file path="src/main/java/com/mcpvp/common/chat/C.java">
  1: package com.mcpvp.common.chat;
  2: 
  3: import org.apache.commons.lang.StringUtils;
  4: import org.bukkit.ChatColor;
  5: 
  6: import java.util.ArrayList;
  7: import java.util.List;
  8: import java.util.Set;
  9: import java.util.stream.Collectors;
 10: import java.util.stream.Stream;
 11: 
 12: 
 13: 
 14: 
 15: 
 16: 
 17: @SuppressWarnings("unused")
 18: public class C {
 19: 
 20:     public static final String BLACK = ChatColor.BLACK.toString();
 21:     public static final String DBLUE = ChatColor.DARK_BLUE.toString();
 22:     public static final String DARK_BLUE = DBLUE;
 23:     public static final String DGREEN = ChatColor.DARK_GREEN.toString();
 24:     public static final String DARK_GREEN = DGREEN;
 25:     public static final String DAQUA = ChatColor.DARK_AQUA.toString();
 26:     public static final String DARK_AQUA = DAQUA;
 27:     public static final String DRED = ChatColor.DARK_RED.toString();
 28:     public static final String DARK_RED = DRED;
 29:     public static final String DPURPLE = ChatColor.DARK_PURPLE.toString();
 30:     public static final String DARK_PURPLE = DPURPLE;
 31:     public static final String GOLD = ChatColor.GOLD.toString();
 32:     public static final String GRAY = ChatColor.GRAY.toString();
 33:     public static final String DGRAY = ChatColor.DARK_GRAY.toString();
 34:     public static final String DARK_GRAY = DGRAY;
 35:     public static final String BLUE = ChatColor.BLUE.toString();
 36:     public static final String GREEN = ChatColor.GREEN.toString();
 37:     public static final String AQUA = ChatColor.AQUA.toString();
 38:     public static final String RED = ChatColor.RED.toString();
 39:     public static final String LPURPLE = ChatColor.LIGHT_PURPLE.toString();
 40:     public static final String LIGHT_PURPLE = LPURPLE;
 41:     public static final String YELLOW = ChatColor.YELLOW.toString();
 42:     public static final String WHITE = ChatColor.WHITE.toString();
 43:     public static final String MAGIC = ChatColor.MAGIC.toString();
 44:     public static final String PURPLE = LPURPLE;
 45:     public static final String CYAN = AQUA;
 46:     public static final String ORANGE = GOLD;
 47:     public static final String R = ChatColor.RESET.toString();
 48:     public static final String RESET = R;
 49:     public static final String B = ChatColor.BOLD.toString();
 50:     public static final String BOLD = B;
 51:     public static final String S = ChatColor.STRIKETHROUGH.toString();
 52:     public static final String STRIKETHROUGH = S;
 53:     public static final String U = ChatColor.UNDERLINE.toString();
 54:     public static final String UNDERLINE = U;
 55:     public static final String I = ChatColor.ITALIC.toString();
 56:     public static final String ITALIC = I;
 57: 
 58: 
 59: 
 60: 
 61:     private static final String COMMAND_SYMBOL = ">";
 62: 
 63: 
 64: 
 65:     private static final String INFO_SYMBOL = "*";
 66: 
 67: 
 68: 
 69:     private static final String WARNING_SYMBOL = "!!";
 70: 
 71: 
 72: 
 73: 
 74: 
 75: 
 76: 
 77: 
 78:     public static String mix(String... codes) {
 79:         Set<ChatColor> colors = Stream.of(codes)
 80:             .map(ChatColor::getLastColors)
 81:             .map(s -> s.substring(1))
 82:             .map(ChatColor::getByChar)
 83:             .collect(Collectors.toSet());
 84:         StringBuilder sb = new StringBuilder();
 85: 
 86: 
 87:         colors.stream().filter(ChatColor::isColor).forEach(sb::append);
 88: 
 89:         colors.stream().filter(ChatColor::isFormat).forEach(sb::append);
 90: 
 91:         return sb.toString();
 92:     }
 93: 
 94: 
 95: 
 96: 
 97: 
 98: 
 99: 
100:     public static String b(String color) {
101:         return color + C.B;
102:     }
103: 
104: 
105: 
106: 
107: 
108: 
109: 
110:     public static String s(String color) {
111:         return color + C.S;
112:     }
113: 
114: 
115: 
116: 
117: 
118: 
119: 
120:     public static String u(String color) {
121:         return color + C.U;
122:     }
123: 
124: 
125: 
126: 
127: 
128: 
129: 
130:     public static String i(String color) {
131:         return color + C.I;
132:     }
133: 
134: 
135: 
136: 
137:     public static String cmd(String color) {
138:         return color + B + COMMAND_SYMBOL + R + GRAY + " ";
139:     }
140: 
141: 
142: 
143: 
144:     public static String cmdSuccess() {
145:         return cmd(GREEN);
146:     }
147: 
148: 
149: 
150: 
151: 
152: 
153:     public static String cmdPass() {
154:         return cmdSuccess();
155:     }
156: 
157: 
158: 
159: 
160:     public static String cmdFail() {
161:         return cmd(RED);
162:     }
163: 
164: 
165: 
166: 
167: 
168:     public static String info(String color) {
169:         return color + B + INFO_SYMBOL + R + GRAY + " ";
170:     }
171: 
172: 
173: 
174: 
175: 
176:     public static String warn(String color) {
177:         return color + B + WARNING_SYMBOL + R + GRAY + " ";
178:     }
179: 
180: 
181: 
182: 
183: 
184: 
185:     public static String highlight(Object text) {
186:         return WHITE + text + GRAY;
187:     }
188: 
189: 
190: 
191: 
192: 
193: 
194: 
195:     public static String highlight(Object text, String color) {
196:         return color + text + GRAY;
197:     }
198: 
199: 
200: 
201: 
202: 
203: 
204: 
205:     public static String hl(Object text, String color) {
206:         return color + text + GRAY;
207:     }
208: 
209: 
210: 
211: 
212: 
213: 
214:     public static String hl(Object text) {
215:         return highlight(text);
216:     }
217: 
218: 
219: 
220: 
221: 
222:     public static String link(String text) {
223:         return link(text, AQUA);
224:     }
225: 
226: 
227: 
228: 
229: 
230: 
231:     public static String link(String text, String color) {
232:         return color + C.U + text + GRAY;
233:     }
234: 
235: 
236: 
237: 
238: 
239: 
240:     public static String hr(String color, int length) {
241:         return color + S + StringUtils.repeat(" ", length) + R;
242:     }
243: 
244: 
245: 
246: 
247: 
248:     public static String strip(String text) {
249:         return ChatColor.stripColor(text);
250:     }
251: 
252: 
253: 
254: 
255: 
256: 
257: 
258: 
259:     public static String translate(char alternate, String message) {
260:         return ChatColor.translateAlternateColorCodes(alternate, message);
261:     }
262: 
263: 
264: 
265: 
266: 
267: 
268: 
269: 
270:     public static String translate(String message) {
271:         return ChatColor.translateAlternateColorCodes('&', message);
272:     }
273: 
274: 
275: 
276: 
277: 
278: 
279:     public static boolean isFormatting(String str) {
280:         return str.equals(R) || str.equals(B) || str.equals(S) || str.equals(U) || str.equals(I);
281:     }
282: 
283: 
284: 
285: 
286: 
287: 
288: 
289: 
290:     public static List<String> wrapWithColor(String string, int lineLength) {
291:         int length = translateLength(string, lineLength);
292:         List<String> lines;
293:         if (length == string.length()) {
294:             lines = new ArrayList<>();
295:             lines.add(string);
296:         } else {
297:             int lastSpace = string.lastIndexOf(' ', length);
298:             length = lastSpace == -1 ? length : lastSpace + 1;
299:             String line = string.substring(0, length).trim();
300:             lines = wrapWithColor(ChatColor.getLastColors(line) + string.substring(length).trim(), lineLength);
301:             lines.add(0, line);
302:         }
303:         return lines;
304:     }
305: 
306: 
307: 
308: 
309: 
310:     @Deprecated
311:     public static int translateLength(String string, int length) {
312:         int nonColorCharCount = 0;
313:         boolean previousWasColorChar = false;
314:         for (int i = 0; i < string.length(); i++) {
315:             if (previousWasColorChar) {
316:                 previousWasColorChar = false;
317:             } else if (string.charAt(i) == ChatColor.COLOR_CHAR) {
318:                 previousWasColorChar = true;
319:             } else {
320:                 nonColorCharCount++;
321:                 if (nonColorCharCount == length) {
322:                     return i + 1;
323:                 }
324:             }
325:         }
326:         return string.length();
327:     }
328: }
</file>

<file path="src/main/java/com/mcpvp/common/chat/Colors.java">
 1: package com.mcpvp.common.chat;
 2: 
 3: import org.bukkit.ChatColor;
 4: import org.bukkit.Color;
 5: import org.bukkit.DyeColor;
 6: 
 7: import java.util.function.Function;
 8: import java.util.stream.Stream;
 9: 
10: 
11: 
12: 
13: 
14: 
15: public enum Colors {
16:     BLACK(DyeColor.BLACK, ChatColor.BLACK, C.BLACK),
17:     DARK_BLUE(DyeColor.BLUE, ChatColor.DARK_BLUE, C.DARK_BLUE),
18:     DARK_GREEN(DyeColor.GREEN, ChatColor.DARK_GREEN, C.DARK_GREEN),
19:     DARK_AQUA(DyeColor.CYAN, ChatColor.DARK_AQUA, C.DARK_AQUA),
20:     DARK_RED(DyeColor.RED, ChatColor.DARK_RED, C.DARK_RED),
21:     DARK_PURPLE(DyeColor.MAGENTA, ChatColor.DARK_PURPLE, C.DARK_PURPLE),
22:     GOLD(DyeColor.ORANGE, ChatColor.GOLD, C.GOLD),
23:     GRAY(DyeColor.GRAY, ChatColor.GRAY, C.GRAY),
24:     DARK_GRAY(DyeColor.GRAY, ChatColor.DARK_GRAY, C.DARK_GRAY),
25:     BLUE(DyeColor.BLUE, ChatColor.BLUE, C.BLUE),
26:     LIGHT_BLUE(DyeColor.LIGHT_BLUE, ChatColor.AQUA, C.AQUA),
27:     GREEN(DyeColor.LIME, ChatColor.GREEN, C.GREEN),
28:     AQUA(DyeColor.CYAN, ChatColor.AQUA, C.AQUA),
29:     RED(DyeColor.RED, ChatColor.RED, C.RED),
30:     PINK(DyeColor.PINK, ChatColor.LIGHT_PURPLE, C.LIGHT_PURPLE),
31:     LIGHT_PURPLE(DyeColor.PURPLE, ChatColor.LIGHT_PURPLE, C.LIGHT_PURPLE),
32:     PURPLE(DyeColor.PURPLE, ChatColor.DARK_PURPLE, C.DARK_PURPLE),
33:     YELLOW(DyeColor.YELLOW, ChatColor.YELLOW, C.YELLOW),
34:     BROWN(DyeColor.BROWN, ChatColor.BLACK, C.BLACK),
35:     WHITE(DyeColor.WHITE, ChatColor.WHITE, C.WHITE);
36: 
37:     public static final Colors[] VALUES = values();
38: 
39:     private final Color COLOR;
40:     private final DyeColor DYE;
41:     private final ChatColor CHAT;
42:     private final String CHAT_STRING;
43: 
44:     Colors(DyeColor dye, ChatColor chat, String string) {
45:         this.COLOR = dye.getColor();
46:         this.DYE = dye;
47:         this.CHAT = chat;
48:         this.CHAT_STRING = string;
49:     }
50: 
51:     public static Colors find(Color col) {
52:         return match(col, Colors::getColor);
53:     }
54: 
55:     public static Colors find(DyeColor col) {
56:         return match(col, Colors::getDye);
57:     }
58: 
59:     public static Colors find(ChatColor col) {
60:         return match(col, Colors::getChat);
61:     }
62: 
63:     public static Colors find(String col) {
64:         return match(col, Colors::getChatString);
65:     }
66: 
67:     private static <T> Colors match(T object, Function<Colors, T> func) {
68:         return Stream.of(Colors.values()).filter(c -> func.apply(c).equals(object)).findFirst().orElse(null);
69:     }
70: 
71:     @Override
72:     public String toString() {
73:         return this.getChat().toString();
74:     }
75: 
76:     public Color getColor() {
77:         return this.COLOR;
78:     }
79: 
80:     public DyeColor getDye() {
81:         return this.DYE;
82:     }
83: 
84:     public ChatColor getChat() {
85:         return this.CHAT;
86:     }
87: 
88:     public String getChatString() {
89:         return this.CHAT_STRING;
90:     }
91: 
92: }
</file>

<file path="src/main/java/com/mcpvp/common/event/EasyCancellableEvent.java">
 1: package com.mcpvp.common.event;
 2: 
 3: import org.bukkit.Bukkit;
 4: import org.bukkit.event.Cancellable;
 5: import org.bukkit.event.Event;
 6: import org.bukkit.event.HandlerList;
 7: 
 8: public class EasyCancellableEvent extends Event implements Cancellable {
 9: 
10:     private static final HandlerList handlers = new HandlerList();
11: 
12:     private boolean cancelled = false;
13: 
14:     @Override
15:     public HandlerList getHandlers() {
16:         return handlers;
17:     }
18: 
19: 
20:     @SuppressWarnings("unused")
21:     public static HandlerList getHandlerList() {
22:         return handlers;
23:     }
24: 
25:     public boolean callIsCancelled() {
26:         Bukkit.getPluginManager().callEvent(this);
27:         return this.isCancelled();
28:     }
29: 
30:     @Override
31:     public boolean isCancelled() {
32:         return this.cancelled;
33:     }
34: 
35:     @Override
36:     public void setCancelled(boolean b) {
37:         this.cancelled = b;
38:     }
39: 
40:     public void cancel() {
41:         this.setCancelled(true);
42:     }
43: 
44: }
</file>

<file path="src/main/java/com/mcpvp/common/event/EasyListener.java">
 1: package com.mcpvp.common.event;
 2: 
 3: import com.mcpvp.common.PluginContainer;
 4: import org.bukkit.Bukkit;
 5: import org.bukkit.event.HandlerList;
 6: import org.bukkit.event.Listener;
 7: 
 8: public interface EasyListener extends Listener, PluginContainer {
 9: 
10:     default EasyListener register() {
11:         Bukkit.getPluginManager().registerEvents(this, this.getPlugin());
12:         return this;
13:     }
14: 
15:     default void unregister() {
16:         HandlerList.unregisterAll(this);
17:     }
18: 
19: }
</file>

<file path="src/main/java/com/mcpvp/common/event/TickEvent.java">
 1: package com.mcpvp.common.event;
 2: 
 3: import com.mcpvp.common.time.Duration;
 4: import lombok.Getter;
 5: import lombok.RequiredArgsConstructor;
 6: 
 7: @Getter
 8: @RequiredArgsConstructor
 9: public class TickEvent extends EasyEvent {
10: 
11:     private final long tick;
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20:     public boolean isInterval(Duration duration) {
21:         return this.tick % duration.ticks() == 0;
22:     }
23: 
24: }
</file>

<file path="src/main/java/com/mcpvp/common/JsonFile.java">
 1: package com.mcpvp.common;
 2: 
 3: import com.fasterxml.jackson.core.type.TypeReference;
 4: import com.fasterxml.jackson.databind.ObjectMapper;
 5: import lombok.RequiredArgsConstructor;
 6: 
 7: import java.io.File;
 8: import java.io.IOException;
 9: import java.util.function.Supplier;
10: 
11: @RequiredArgsConstructor
12: public class JsonFile<T> {
13: 
14:     private final File file;
15:     private final ObjectMapper objectMapper;
16:     private final TypeReference<T> type;
17:     private final Supplier<T> defaults;
18: 
19:     public void save(T data) throws IOException {
20:         if (!this.file.exists()) {
21: 
22:             this.file.createNewFile();
23:         }
24: 
25:         this.objectMapper.writeValue(this.file, data);
26:     }
27: 
28:     public T read() throws IOException {
29:         if (!this.file.exists()) {
30:             T data = this.defaults.get();
31:             this.save(data);
32:             return data;
33:         }
34: 
35:         return this.objectMapper.readValue(this.file, this.type);
36:     }
37: 
38: }
</file>

<file path="src/main/java/com/mcpvp/common/kit/KitAttemptSelectEvent.java">
 1: package com.mcpvp.common.kit;
 2: 
 3: import com.mcpvp.common.event.EasyCancellableEvent;
 4: import lombok.Data;
 5: import lombok.EqualsAndHashCode;
 6: import lombok.RequiredArgsConstructor;
 7: import org.bukkit.entity.Player;
 8: 
 9: 
10: 
11: 
12: @Data
13: @EqualsAndHashCode(callSuper = false)
14: @RequiredArgsConstructor
15: public class KitAttemptSelectEvent extends EasyCancellableEvent {
16: 
17:     private final Player player;
18:     private final KitDefinition kitDefinition;
19: 
20:     private String denial;
21: 
22:     public void deny(String reason) {
23:         this.denial = reason;
24:         this.cancel();
25:     }
26: 
27: }
</file>

<file path="src/main/java/com/mcpvp/common/movement/CancelNextFallTask.java">
 1: package com.mcpvp.common.movement;
 2: 
 3: import com.mcpvp.common.event.EasyListener;
 4: import com.mcpvp.common.event.TickEvent;
 5: import com.mcpvp.common.util.EntityUtil;
 6: import lombok.Getter;
 7: import org.bukkit.entity.Player;
 8: import org.bukkit.event.EventHandler;
 9: import org.bukkit.plugin.Plugin;
10: 
11: public class CancelNextFallTask implements EasyListener {
12: 
13:     @Getter
14:     private final Plugin plugin;
15:     private final Player player;
16: 
17:     public CancelNextFallTask(Plugin plugin, Player player) {
18:         this.plugin = plugin;
19:         this.player = player;
20:     }
21: 
22:     @EventHandler
23:     public void onTick(TickEvent event) {
24:         if (!this.player.isOnline()) {
25:             this.unregister();
26:             return;
27:         }
28: 
29:         if (EntityUtil.isOnGround(this.player)) {
30:             this.player.setFallDistance(0);
31:             this.unregister();
32:         } else {
33:             this.player.setFallDistance(-100);
34:         }
35:     }
36: 
37: }
</file>

<file path="src/main/java/com/mcpvp/common/movement/VelocityManager.java">
 1: package com.mcpvp.common.movement;
 2: 
 3: import org.bukkit.Bukkit;
 4: import org.bukkit.entity.Entity;
 5: import org.bukkit.entity.Player;
 6: import org.bukkit.plugin.Plugin;
 7: import org.bukkit.scheduler.BukkitTask;
 8: import org.bukkit.util.Vector;
 9: 
10: 
11: 
12: 
13: public class VelocityManager implements Runnable {
14: 
15:     private static final boolean smooth = false;
16: 
17:     public static final double X_INTENSITY = 3;
18:     public static final double Y_INTENSITY = 1;
19:     private final Vector vector;
20:     private final Entity player;
21:     private final BukkitTask task;
22:     private final Runnable afterLaunch;
23: 
24:     public VelocityManager(Plugin plugin, Entity player, Vector vector, Runnable afterLaunch) {
25:         this.player = player;
26:         this.vector = vector;
27:         this.task = Bukkit.getScheduler().runTaskTimer(plugin, this, 0, 1);
28:         this.afterLaunch = afterLaunch;
29:         new CancelNextFallTask(plugin, (Player) player).register();
30:     }
31: 
32:     @Override
33:     public void run() {
34:         if (((this.player instanceof Player p) && !p.isOnline()) || this.player.isDead()) {
35:             this.task.cancel();
36:             return;
37:         }
38:         int x = this.vector.getBlockX();
39:         int y = this.vector.getBlockY();
40:         int z = this.vector.getBlockZ();
41:         if (x == 0 && y == 0 && z == 0) {
42:             if (!smooth) {
43:                 this.player.setVelocity(new Vector(0, 0, 0));
44:             }
45: 
46:             this.task.cancel();
47: 
48:             if (this.afterLaunch != null) {
49:                 this.afterLaunch.run();
50:             }
51: 
52:             return;
53:         }
54:         Vector result = new Vector();
55:         if (x > 0) {
56:             this.vector.setX(x - 1);
57:             result.setX(result.getX() + X_INTENSITY);
58:         } else if (x < 0) {
59:             this.vector.setX(x + 1);
60:             result.setX(result.getX() - X_INTENSITY);
61:         }
62:         if (y > 0) {
63:             this.vector.setY(y - 1);
64:             result.setY(result.getY() + Y_INTENSITY);
65:         } else if (y < 0) {
66:             this.vector.setY(y + 1);
67:             result.setY(result.getY() - Y_INTENSITY);
68:         }
69:         if (z > 0) {
70:             this.vector.setZ(z - 1);
71:             result.setZ(result.getZ() + X_INTENSITY);
72:         } else if (z < 0) {
73:             this.vector.setZ(z + 1);
74:             result.setZ(result.getZ() - X_INTENSITY);
75:         }
76: 
77:         this.player.setVelocity(result);
78:     }
79: 
80: }
</file>

<file path="src/main/java/com/mcpvp/common/preference/Preference.java">
 1: package com.mcpvp.common.preference;
 2: 
 3: import com.fasterxml.jackson.core.type.TypeReference;
 4: import lombok.Data;
 5: import lombok.RequiredArgsConstructor;
 6: 
 7: @Data
 8: @RequiredArgsConstructor(staticName = "of")
 9: public class Preference<T> {
10: 
11:     private final String key;
12:     private final TypeReference<T> type;
13: 
14:     public static <T> Preference<T> of(String key, Class<T> type) {
15:         return of(key, new TypeReference<>() {});
16:     }
17: 
18: }
</file>

<file path="src/main/java/com/mcpvp/common/preference/PreferenceManager.java">
  1: package com.mcpvp.common.preference;
  2: 
  3: import com.fasterxml.jackson.core.type.TypeReference;
  4: import com.fasterxml.jackson.databind.JsonNode;
  5: import com.fasterxml.jackson.databind.ObjectMapper;
  6: import com.mcpvp.common.task.EasyTask;
  7: import org.bukkit.entity.Player;
  8: import org.bukkit.plugin.Plugin;
  9: 
 10: import java.io.File;
 11: import java.io.IOException;
 12: import java.util.HashMap;
 13: import java.util.Map;
 14: import java.util.Optional;
 15: import java.util.UUID;
 16: 
 17: 
 18: 
 19: 
 20: public class PreferenceManager {
 21: 
 22:     private final Plugin plugin;
 23:     private final ObjectMapper objectMapper;
 24:     private final File file;
 25:     private final Map<UUID, Map<String, JsonNode>> stored = new HashMap<>();
 26: 
 27: 
 28: 
 29: 
 30: 
 31: 
 32: 
 33: 
 34:     public PreferenceManager(Plugin plugin, ObjectMapper objectMapper, File file) {
 35:         this.plugin = plugin;
 36:         this.objectMapper = objectMapper;
 37:         this.file = file;
 38:         this.load();
 39:     }
 40: 
 41: 
 42: 
 43: 
 44: 
 45: 
 46: 
 47: 
 48: 
 49: 
 50:     public <T> void store(
 51:         Player player, Preference<T> preference, T value
 52:     ) {
 53:         this.stored.computeIfAbsent(player.getUniqueId(), p -> new HashMap<>())
 54:             .put(preference.getKey(), this.objectMapper.valueToTree(value));
 55: 
 56: 
 57:         EasyTask.of(this::save).runTaskAsynchronously(this.plugin);
 58:     }
 59: 
 60: 
 61: 
 62: 
 63: 
 64: 
 65: 
 66: 
 67: 
 68:     public <T> Optional<T> find(Player player, Preference<T> preference) {
 69:         if (!this.stored.containsKey(player.getUniqueId())) {
 70:             return Optional.empty();
 71:         }
 72: 
 73:         if (!this.stored.get(player.getUniqueId()).containsKey(preference.getKey())) {
 74:             return Optional.empty();
 75:         }
 76: 
 77:         return Optional.ofNullable(
 78:             this.objectMapper.convertValue(
 79:                 this.stored.get(player.getUniqueId()).get(preference.getKey()),
 80:                 preference.getType()
 81:             )
 82:         );
 83:     }
 84: 
 85:     private void load() {
 86:         synchronized (this) {
 87:             try {
 88:                 if (this.file.createNewFile()) {
 89:                     this.objectMapper.writeValue(this.file, this.stored);
 90:                 }
 91: 
 92:                 Map<UUID, Map<String, JsonNode>> loaded = this.objectMapper.readValue(this.file, new TypeReference<>() {
 93:                 });
 94:                 this.stored.putAll(loaded);
 95:             } catch (IOException e) {
 96:                 throw new RuntimeException("Failed to load preferences file from " + this.file, e);
 97:             }
 98:         }
 99:     }
100: 
101:     private void save() {
102:         synchronized (this) {
103:             try {
104:                 this.objectMapper.writeValue(this.file, this.stored);
105:             } catch (IOException e) {
106:                 throw new RuntimeException("Failed to save preferences file to " + this.file, e);
107:             }
108:         }
109:     }
110: 
111: }
</file>

<file path="src/main/java/com/mcpvp/common/shape/Cuboid.java">
  1: package com.mcpvp.common.shape;
  2: 
  3: import lombok.Getter;
  4: import org.bukkit.Location;
  5: 
  6: import java.util.HashSet;
  7: import java.util.Set;
  8: 
  9: 
 10: 
 11: 
 12: 
 13: 
 14: 
 15: 
 16: 
 17: @Getter
 18: public class Cuboid extends Shape {
 19: 
 20:     private final Location corner1;
 21:     private final Location corner2;
 22: 
 23:     public Cuboid(Location corner1, Location corner2) {
 24:         if (corner1.getWorld() != corner2.getWorld()) {
 25:             throw new IllegalArgumentException("corners must be in the same world");
 26:         }
 27:         this.corner1 = corner1;
 28:         this.corner2 = corner2;
 29:     }
 30: 
 31:     @Override
 32:     public boolean contains(Location location) {
 33:         if (location == null) {
 34:             throw new IllegalArgumentException("location can't be null");
 35:         }
 36:         if (this.corner1 == null) {
 37:             throw new NullPointerException("corner1 can't be null");
 38:         }
 39:         if (location.getWorld() != this.corner1.getWorld()) {
 40:             return false;
 41:         }
 42: 
 43:         if (this.corner2 == null) {
 44:             if (this.corner1.getBlockX() != location.getBlockX()) {
 45:                 return false;
 46:             }
 47:             if (this.corner1.getBlockY() != location.getBlockY()) {
 48:                 return false;
 49:             }
 50:             return this.corner1.getBlockZ() == location.getBlockZ();
 51:         }
 52:         if (!this.isWithinCoords(this.corner1.getBlockX(), this.corner2.getBlockX(), location.getBlockX())) {
 53:             return false;
 54:         }
 55:         if (!this.isWithinCoords(this.corner1.getBlockY(), this.corner2.getBlockY(), location.getBlockY())) {
 56:             return false;
 57:         }
 58:         return this.isWithinCoords(this.corner1.getBlockZ(), this.corner2.getBlockZ(), location.getBlockZ());
 59:     }
 60: 
 61:     private boolean isWithinCoords(double coord1, double coord2, double value) {
 62:         if (coord1 > coord2) {
 63:             return (value <= coord1 && value >= coord2);
 64:         }
 65:         return (value <= coord2 && value >= coord1);
 66:     }
 67: 
 68: 
 69: 
 70: 
 71: 
 72: 
 73:     public Location getCenter() {
 74:         int x1 = this.corner1.getBlockX();
 75:         int x2 = this.corner2.getBlockX();
 76: 
 77:         int y1 = this.corner1.getBlockY();
 78:         int y2 = this.corner2.getBlockY();
 79: 
 80:         int z1 = this.corner1.getBlockZ();
 81:         int z2 = this.corner2.getBlockZ();
 82: 
 83:         return new Location(this.corner1.getWorld(), (x1 + x2) / 2, (y1 + y2) / 2, (z1 + z2) / 2);
 84:     }
 85: 
 86:     @Override
 87:     public Set<Location> getFaces() {
 88:         Set<Location> faceLocations = new HashSet<>();
 89:         if (this.corner1 == null) {
 90:             throw new NullPointerException("corner1 can't be null");
 91:         }
 92:         if (this.corner2 == null) {
 93:             faceLocations.add(this.corner1);
 94:             return faceLocations;
 95:         }
 96:         int minX = Math.min(this.corner1.getBlockX(), this.corner2.getBlockX());
 97:         int maxX = Math.max(this.corner1.getBlockX(), this.corner2.getBlockX());
 98:         int minY = Math.min(this.corner1.getBlockY(), this.corner2.getBlockY());
 99:         int maxY = Math.max(this.corner1.getBlockY(), this.corner2.getBlockY());
100:         int minZ = Math.min(this.corner1.getBlockZ(), this.corner2.getBlockZ());
101:         int maxZ = Math.max(this.corner1.getBlockZ(), this.corner2.getBlockZ());
102:         for (int x = minX; x <= maxX; x++) {
103:             for (int y = minY; y <= maxY; y++) {
104:                 Location minZFace = new Location(this.corner1.getWorld(), x, y, minZ);
105:                 Location maxZFace = new Location(this.corner2.getWorld(), x, y, maxZ);
106:                 faceLocations.add(minZFace);
107:                 faceLocations.add(maxZFace);
108:             }
109:         }
110:         for (int z = minZ; z <= maxZ; z++) {
111:             for (int y = minY; y <= maxY; y++) {
112:                 Location minXFace = new Location(this.corner1.getWorld(), minX, y, z);
113:                 Location maxXFace = new Location(this.corner1.getWorld(), maxX, y, z);
114:                 faceLocations.add(minXFace);
115:                 faceLocations.add(maxXFace);
116:             }
117:         }
118:         for (int x = minX; x <= maxX; x++) {
119:             for (int z = minZ; z <= maxZ; z++) {
120:                 Location minYFace = new Location(this.corner1.getWorld(), x, minY, z);
121:                 Location maxYFace = new Location(this.corner1.getWorld(), x, maxY, z);
122:                 faceLocations.add(minYFace);
123:                 faceLocations.add(maxYFace);
124:             }
125:         }
126:         return faceLocations;
127:     }
128: 
129: }
</file>

<file path="src/main/java/com/mcpvp/common/shape/Shape.java">
 1: package com.mcpvp.common.shape;
 2: 
 3: import org.bukkit.Location;
 4: import org.bukkit.block.Block;
 5: import org.bukkit.entity.Entity;
 6: 
 7: 
 8: 
 9: 
10: public abstract class Shape {
11: 
12: 
13: 
14: 
15: 
16:     public abstract boolean contains(Location location);
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24:     public boolean contains(Entity entity) {
25:         return this.contains(entity.getLocation());
26:     }
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34:     public boolean contains(Block block) {
35:         return this.contains(block.getLocation());
36:     }
37: 
38: 
39: 
40: 
41: 
42:     public abstract Iterable<Location> getFaces();
43: 
44: }
</file>

<file path="src/main/java/com/mcpvp/common/structure/Structure.java">
  1: package com.mcpvp.common.structure;
  2: 
  3: import com.mcpvp.common.EasyLifecycle;
  4: import com.mcpvp.common.event.EasyListener;
  5: import com.mcpvp.common.time.Duration;
  6: import lombok.Getter;
  7: import lombok.RequiredArgsConstructor;
  8: import org.bukkit.Bukkit;
  9: import org.bukkit.Location;
 10: import org.bukkit.block.Block;
 11: import org.bukkit.entity.Player;
 12: 
 13: import java.util.ArrayList;
 14: import java.util.Collections;
 15: import java.util.List;
 16: 
 17: 
 18: 
 19: 
 20: 
 21: @RequiredArgsConstructor
 22: public abstract class Structure extends EasyLifecycle implements EasyListener {
 23: 
 24:     private final StructureManager manager;
 25:     @Getter
 26:     private final Player owner;
 27:     private final List<StructureBlock> blocks = new ArrayList<>();
 28:     @Getter
 29:     private Block center;
 30: 
 31: 
 32: 
 33: 
 34: 
 35: 
 36: 
 37: 
 38:     public List<StructureViolation> place(Block center) {
 39:         StructureBuilder builder = new StructureBuilder(this.manager);
 40:         this.build(center, builder);
 41: 
 42:         if (!builder.getViolations().isEmpty()) {
 43: 
 44: 
 45:             this.shutdown();
 46:             return builder.getViolations();
 47:         }
 48: 
 49: 
 50:         builder.complete();
 51:         this.blocks.addAll(builder.getBuilt());
 52:         this.manager.onBuild(this);
 53:         this.attach((EasyListener) this);
 54:         this.center = center;
 55: 
 56:         return Collections.emptyList();
 57:     }
 58: 
 59: 
 60: 
 61: 
 62: 
 63: 
 64: 
 65: 
 66:     protected abstract void build(Block center, StructureBuilder builder);
 67: 
 68: 
 69: 
 70: 
 71:     public List<Block> getBlocks() {
 72:         return this.blocks.stream().map(StructureBlock::getBlock).toList();
 73:     }
 74: 
 75: 
 76: 
 77: 
 78:     public void remove() {
 79:         this.shutdown();
 80:     }
 81: 
 82:     @Override
 83:     public void shutdown() {
 84:         super.shutdown();
 85:         this.blocks.forEach(StructureBlock::restore);
 86:         this.manager.onRemove(this);
 87:     }
 88: 
 89: 
 90: 
 91: 
 92: 
 93: 
 94: 
 95:     protected void removeAfter(Duration duration) {
 96:         this.attach(Bukkit.getScheduler().runTaskLater(this.getPlugin(), this::remove, duration.ticks()));
 97:     }
 98: 
 99:     public double distance(Location location) {
100:         return this.getCenter().getLocation().distance(location);
101:     }
102: 
103: }
</file>

<file path="src/main/java/com/mcpvp/common/structure/StructureBlock.java">
 1: package com.mcpvp.common.structure;
 2: 
 3: import lombok.Getter;
 4: import lombok.RequiredArgsConstructor;
 5: import lombok.extern.log4j.Log4j2;
 6: import org.bukkit.block.Block;
 7: import org.bukkit.block.BlockState;
 8: 
 9: 
10: 
11: 
12: @Log4j2
13: @Getter
14: @RequiredArgsConstructor
15: public class StructureBlock {
16: 
17:     private final Block block;
18:     private final BlockState original;
19: 
20:     @SuppressWarnings("deprecation")
21:     public void restore() {
22:         log.debug("Restoring {} to {}", this.block.getLocation(), this.original.getType());
23:         this.block.setType(this.original.getType(), false);
24:         this.block.setData(this.original.getData().getData(), false);
25:     }
26: 
27: }
</file>

<file path="src/main/java/com/mcpvp/common/structure/StructureBuilder.java">
  1: package com.mcpvp.common.structure;
  2: 
  3: import lombok.Getter;
  4: import lombok.RequiredArgsConstructor;
  5: import org.bukkit.Material;
  6: import org.bukkit.block.Block;
  7: 
  8: import java.util.*;
  9: import java.util.function.Consumer;
 10: 
 11: 
 12: 
 13: 
 14: 
 15: 
 16: 
 17: @RequiredArgsConstructor
 18: public class StructureBuilder {
 19: 
 20:     private final StructureManager manager;
 21:     private final Set<String> ignoredRestrictions = new HashSet<>();
 22: 
 23: 
 24: 
 25:     private final Map<Block, Consumer<Block>> queued = new HashMap<>();
 26: 
 27: 
 28: 
 29:     @Getter
 30:     private final List<StructureBlock> built = new ArrayList<>();
 31: 
 32: 
 33: 
 34:     @Getter
 35:     private final List<StructureViolation> violations = new ArrayList<>();
 36: 
 37: 
 38: 
 39: 
 40: 
 41: 
 42: 
 43: 
 44: 
 45:     public void setBlock(Block block, Consumer<Block> placer) {
 46:         if (this.queued.containsKey(block)) {
 47:             throw new IllegalArgumentException("Location already has a block in structure");
 48:         }
 49: 
 50: 
 51:         List<StructureViolation> violations = this.manager.check(block).stream().filter(violation -> {
 52:             return !this.ignoredRestrictions.contains(violation.getKey());
 53:         }).toList();
 54:         this.violations.addAll(violations);
 55: 
 56: 
 57: 
 58:         this.queued.put(block, placer);
 59:     }
 60: 
 61: 
 62: 
 63: 
 64: 
 65: 
 66: 
 67:     public void setBlock(Block block, Material material) {
 68:         this.setBlock(block, b -> b.setType(material, false));
 69:     }
 70: 
 71: 
 72: 
 73: 
 74: 
 75: 
 76:     public void ignoreRestriction(String key) {
 77:         this.ignoredRestrictions.add(key);
 78:     }
 79: 
 80: 
 81: 
 82: 
 83: 
 84: 
 85:     public void ignoreRestrictions(String... keys) {
 86:         this.ignoredRestrictions.addAll(Arrays.asList(keys));
 87:     }
 88: 
 89: 
 90: 
 91: 
 92: 
 93:     public void complete() {
 94:         if (!this.violations.isEmpty()) {
 95:             throw new IllegalStateException("Attempted to place structure with violations: " + this.violations);
 96:         }
 97: 
 98:         this.queued.forEach((block, placer) -> {
 99:             StructureBlock placed = new StructureBlock(block, block.getState());
100:             this.built.add(placed);
101:             placer.accept(block);
102:         });
103:     }
104: 
105: }
</file>

<file path="src/main/java/com/mcpvp/common/structure/StructureManager.java">
 1: package com.mcpvp.common.structure;
 2: 
 3: import org.bukkit.block.Block;
 4: 
 5: import java.util.ArrayList;
 6: import java.util.List;
 7: import java.util.Optional;
 8: 
 9: 
10: 
11: 
12: public class StructureManager {
13: 
14:     private final List<StructureViolationChecker> checkers = new ArrayList<>();
15:     private final List<Structure> structures = new ArrayList<>();
16: 
17:     {
18:         this.checkers.add(block -> {
19:             if (this.structures.stream().anyMatch(s -> s.getBlocks().contains(block))) {
20:                 return Optional.of(new StructureViolation("STRUCTURE_ALREADY_PRESENT", "Something is already placed here"));
21:             }
22:             return Optional.empty();
23:         });
24:     }
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32:     public List<StructureViolation> check(Block block) {
33:         List<StructureViolation> violations = new ArrayList<>();
34:         this.checkers.forEach(checker -> {
35:             checker.check(block).ifPresent(violations::add);
36:         });
37:         return violations;
38:     }
39: 
40:     public void onBuild(Structure structure) {
41:         this.structures.add(structure);
42:     }
43: 
44:     public void onRemove(Structure structure) {
45:         this.structures.remove(structure);
46:     }
47: 
48:     public void registerChecker(StructureViolationChecker checker) {
49:         this.checkers.add(checker);
50:     }
51: 
52:     public List<Structure> getStructures() {
53:         return new ArrayList<>(this.structures);
54:     }
55: }
</file>

<file path="src/main/java/com/mcpvp/common/time/Expiration.java">
 1: package com.mcpvp.common.time;
 2: 
 3: public class Expiration {
 4: 
 5:     private long expiration = 0;
 6: 
 7: 
 8: 
 9: 
10: 
11: 
12: 
13:     public static Expiration after(Duration duration) {
14:         return new Expiration().expireIn(duration);
15:     }
16: 
17: 
18: 
19: 
20: 
21:     public Expiration expireIn(Duration duration) {
22:         this.expiration = System.currentTimeMillis() + duration.toMilliseconds();
23:         return this;
24:     }
25: 
26: 
27: 
28: 
29:     public boolean isExpired() {
30:         return System.currentTimeMillis() >= this.expiration;
31:     }
32: 
33: 
34: 
35: 
36:     public void expireNow() {
37:         this.expiration = 0;
38:     }
39: 
40: 
41: 
42: 
43:     public Duration getRemaining() {
44:         return Duration.ms(this.expiration - System.currentTimeMillis());
45:     }
46: 
47: 
48: 
49: 
50: 
51:     public float getCompletionPercent(Duration total) {
52:         return Math.min(1, 1 - ((float) this.getRemaining().ticks() / total.ticks()));
53:     }
54: 
55: }
</file>

<file path="src/main/java/com/mcpvp/common/util/LookUtil.java">
  1: package com.mcpvp.common.util;
  2: 
  3: import net.minecraft.server.v1_8_R3.AxisAlignedBB;
  4: import org.bukkit.Location;
  5: import org.bukkit.craftbukkit.v1_8_R3.entity.CraftEntity;
  6: import org.bukkit.entity.Entity;
  7: import org.bukkit.entity.Player;
  8: import org.bukkit.util.Vector;
  9: 
 10: import java.util.ArrayList;
 11: import java.util.List;
 12: import java.util.Optional;
 13: 
 14: public class LookUtil {
 15: 
 16:     public static Location lookAt(Location loc, Location lookAt) {
 17: 
 18:         loc = loc.clone();
 19: 
 20: 
 21:         double dx = lookAt.getX() - loc.getX();
 22:         double dy = lookAt.getY() - loc.getY();
 23:         double dz = lookAt.getZ() - loc.getZ();
 24: 
 25: 
 26:         if (dx != 0) {
 27: 
 28:             if (dx < 0) {
 29:                 loc.setYaw((float) (1.5 * Math.PI));
 30:             } else {
 31:                 loc.setYaw((float) (0.5 * Math.PI));
 32:             }
 33:             loc.setYaw(loc.getYaw() - (float) Math.atan(dz / dx));
 34:         } else if (dz < 0) {
 35:             loc.setYaw((float) Math.PI);
 36:         }
 37: 
 38: 
 39:         double dxz = Math.sqrt(Math.pow(dx, 2) + Math.pow(dz, 2));
 40: 
 41: 
 42:         loc.setPitch((float) -Math.atan(dy / dxz));
 43: 
 44: 
 45:         loc.setYaw(-loc.getYaw() * 180f / (float) Math.PI);
 46:         loc.setPitch(loc.getPitch() * 180f / (float) Math.PI);
 47: 
 48:         return loc;
 49:     }
 50: 
 51:     public static Optional<Player> getFirstPlayerInLineOfSight(Player viewer) {
 52:         List<Player> candidates = viewer.getNearbyEntities(100, 100, 100).stream()
 53:             .filter(Player.class::isInstance)
 54:             .map(Player.class::cast)
 55:             .filter(viewer::hasLineOfSight)
 56:             .toList();
 57: 
 58:         return traverse(viewer.getEyeLocation().toVector(), viewer.getEyeLocation().getDirection(), 100, 0.35)
 59:             .stream()
 60:             .map(vector -> {
 61:                 return candidates.stream().filter(candidate -> {
 62:                     return new BoundingBox(candidate, 0.25).isIntersectedBy(vector);
 63:                 }).findFirst();
 64:             })
 65:             .filter(Optional::isPresent)
 66:             .map(Optional::get)
 67:             .findFirst();
 68:     }
 69: 
 70:     public static List<Vector> traverse(Vector origin, Vector direction, double blocksAway, double accuracy) {
 71:         List<Vector> positions = new ArrayList<>();
 72:         for (double d = 0; d <= blocksAway; d += accuracy) {
 73:             positions.add(direction.clone().normalize().multiply(d).add(origin));
 74:         }
 75:         return positions;
 76:     }
 77: 
 78:     public static class BoundingBox {
 79: 
 80:         private final Vector max;
 81:         private final Vector min;
 82: 
 83:         public BoundingBox(Entity entity, double buffer) {
 84:             AxisAlignedBB bb = ((CraftEntity) entity).getHandle().getBoundingBox().grow(buffer, buffer, buffer);
 85:             this.min = new Vector(bb.a, bb.b, bb.c);
 86:             this.max = new Vector(bb.d, bb.e, bb.f);
 87:         }
 88: 
 89:         public boolean isIntersectedBy(Vector position) {
 90:             if (position.getX() < this.min.getX() || position.getX() > this.max.getX()) {
 91:                 return false;
 92:             } else if (position.getY() < this.min.getY() || position.getY() > this.max.getY()) {
 93:                 return false;
 94:             } else if (position.getZ() < this.min.getZ() || position.getZ() > this.max.getZ()) {
 95:                 return false;
 96:             }
 97:             return true;
 98:         }
 99: 
100:     }
101: 
102: }
</file>

<file path="src/main/java/com/mcpvp/common/util/nms/ActionbarUtil.java">
 1: package com.mcpvp.common.util.nms;
 2: 
 3: import net.minecraft.server.v1_8_R3.IChatBaseComponent;
 4: import net.minecraft.server.v1_8_R3.PacketPlayOutChat;
 5: import org.bukkit.entity.Player;
 6: 
 7: public class ActionbarUtil {
 8: 
 9:     public static void send(Player player, String message) {
10:         PacketUtil.sendPacket(player, createActionBarPacket(message));
11:     }
12: 
13:     private static PacketPlayOutChat createActionBarPacket(String message) {
14:         String msg = "{\"text\":\"" + message + "\"}";
15:         return new PacketPlayOutChat(IChatBaseComponent.ChatSerializer.a(msg), (byte) 2);
16:     }
17: 
18: }
</file>

<file path="src/main/java/com/mcpvp/common/util/nms/PacketUtil.java">
 1: package com.mcpvp.common.util.nms;
 2: 
 3: import net.minecraft.server.v1_8_R3.Packet;
 4: import org.bukkit.craftbukkit.v1_8_R3.entity.CraftPlayer;
 5: import org.bukkit.entity.Player;
 6: 
 7: public class PacketUtil {
 8: 
 9:     public static void sendPacket(Player player, Packet<?> packet) {
10:         ((CraftPlayer) player).getHandle().playerConnection.sendPacket(packet);
11:     }
12: 
13: }
</file>

<file path="src/main/java/com/mcpvp/common/util/nms/TitleUtil.java">
 1: package com.mcpvp.common.util.nms;
 2: 
 3: import com.mcpvp.common.time.Duration;
 4: import net.minecraft.server.v1_8_R3.ChatComponentText;
 5: import net.minecraft.server.v1_8_R3.PacketPlayOutTitle;
 6: import org.bukkit.ChatColor;
 7: import org.bukkit.entity.Player;
 8: 
 9: public class TitleUtil {
10: 
11:     public static void sendTitle(Player player, String title, String subtitle, Duration fadeIn, Duration stay, Duration fadeOut) {
12:         resetTitle(player);
13: 
14: 
15:         if (fadeIn != null && stay != null && fadeOut != null) {
16:             PacketUtil.sendPacket(player, new PacketPlayOutTitle(fadeIn.toTicks(), stay.toTicks(), fadeOut.toTicks()));
17:         }
18: 
19: 
20:         PacketUtil.sendPacket(player, new PacketPlayOutTitle(PacketPlayOutTitle.EnumTitleAction.TITLE, new ChatComponentText(ChatColor.translateAlternateColorCodes('&', title))));
21: 
22: 
23:         if (!subtitle.isEmpty()) {
24:             PacketUtil.sendPacket(player, new PacketPlayOutTitle(PacketPlayOutTitle.EnumTitleAction.SUBTITLE, new ChatComponentText(ChatColor.translateAlternateColorCodes('&', subtitle))));
25:         }
26:     }
27: 
28:     public static void clearTitle(Player player) {
29:         PacketUtil.sendPacket(player, new PacketPlayOutTitle(PacketPlayOutTitle.EnumTitleAction.CLEAR, null));
30:     }
31: 
32:     public static void resetTitle(Player player) {
33:         PacketUtil.sendPacket(player, new PacketPlayOutTitle(PacketPlayOutTitle.EnumTitleAction.RESET, null));
34:     }
35: 
36: }
</file>

<file path="src/main/java/com/mcpvp/common/util/ScoreboardUtil.java">
  1: package com.mcpvp.common.util;
  2: 
  3: import com.mcpvp.common.chat.C;
  4: import org.bukkit.scoreboard.Objective;
  5: import org.bukkit.scoreboard.Scoreboard;
  6: import org.bukkit.scoreboard.Team;
  7: 
  8: import java.util.List;
  9: 
 10: 
 11: 
 12: 
 13: 
 14: 
 15: 
 16: public class ScoreboardUtil {
 17: 
 18:     private static final int MAX_LENGTH = 48;
 19: 
 20: 
 21: 
 22: 
 23: 
 24: 
 25: 
 26: 
 27: 
 28: 
 29:     public static String autoSize(String entryName, Object entryValue) {
 30:         int valLength = (" " + entryValue).length();
 31:         if (MAX_LENGTH - valLength < 0) {
 32:             return entryValue.toString();
 33:         }
 34:         entryName = entryName.substring(0, Math.min(MAX_LENGTH - valLength, entryName.length()));
 35: 
 36:         return entryName + " " + entryValue;
 37:     }
 38: 
 39: 
 40: 
 41: 
 42: 
 43: 
 44: 
 45: 
 46: 
 47: 
 48: 
 49: 
 50: 
 51:     public static String autoSize(String entryName, Object entryValue, String... fallbacks) {
 52:         if ((entryName + " " + entryValue).length() > MAX_LENGTH) {
 53:             for (String newName : fallbacks) {
 54:                 if ((newName + " " + entryValue).length() <= MAX_LENGTH) {
 55:                     return newName + " " + entryValue;
 56:                 }
 57:             }
 58:         }
 59: 
 60:         return autoSize(entryName, entryValue);
 61:     }
 62: 
 63: 
 64: 
 65: 
 66: 
 67: 
 68: 
 69:     public static void addLargeScores(Scoreboard board, Objective objective, List<String> entries) {
 70:         for (String entry : entries) {
 71:             if (entry.length() > 16) {
 72:                 String prefix;
 73:                 String entrie;
 74:                 String suffix = "";
 75:                 if (entry.length() <= 32) {
 76: 
 77:                     prefix = entry.substring(0, 16);
 78:                     entrie = entry.substring(16);
 79:                 } else {
 80: 
 81:                     prefix = entry.substring(0, 16);
 82:                     entrie = entry.substring(16, 32);
 83:                     suffix = entry.substring(32);
 84:                 }
 85:                 if (board.getTeam(prefix) != null) {
 86:                     board.getTeam(prefix).unregister();
 87:                 }
 88:                 Team t = board.registerNewTeam(prefix);
 89:                 t.setPrefix(prefix);
 90:                 t.setSuffix(suffix);
 91: 
 92: 
 93: 
 94:                 t.addEntry((entrie + C.R).transform(s -> s.substring(0, Math.min(s.length(), 16))));
 95:             }
 96: 
 97:             objective.getScore(entry).setScore(entries.size() - entries.indexOf(entry));
 98:         }
 99:     }
100: 
101: 
102: 
103: 
104: 
105:     public static List<String> wrap(String entry) {
106:         return C.wrapWithColor(entry, MAX_LENGTH);
107:     }
108: 
109: 
110: 
111: 
112: 
113: 
114: 
115:     public static void resetChanged(Scoreboard scoreboard, List<String> scores) {
116:         for (String entry : scoreboard.getEntries()) {
117:             if (!scores.contains(entry)) {
118:                 scoreboard.resetScores(entry);
119:             }
120:         }
121:     }
122: 
123: }
</file>

<file path=".gitignore">
 1: # Ignore Gradle project-specific cache directory
 2: .gradle
 3: gradlew
 4: 
 5: # Ignore Gradle build output directory
 6: build
 7: bin
 8: */target
 9: 
10: # IDE
11: .idea
12: .vscode
13: 
14: # Server files
15: server
16: 
17: # Repomix
18: repomix-output.xml
</file>

<file path="src/main/java/com/mcpvp/battle/BattlePreferences.java">
 1: package com.mcpvp.battle;
 2: 
 3: import com.fasterxml.jackson.core.type.TypeReference;
 4: import com.mcpvp.battle.flag.display.FlagDisplayChannel;
 5: import com.mcpvp.battle.role.Role;
 6: import com.mcpvp.common.preference.Preference;
 7: 
 8: import java.util.Set;
 9: 
10: public class BattlePreferences {
11: 
12:     public static final Preference<Set<FlagDisplayChannel>> FLAG_DISPLAY =
13:             Preference.of("flag.display", new TypeReference<>() {});
14: 
15: 
16:     public static final Preference<Role> ROLE =
17:             Preference.of("role", new TypeReference<>() {});
18: }
</file>

<file path="src/main/java/com/mcpvp/battle/command/QuickCommand.java">
 1: package com.mcpvp.battle.command;
 2: 
 3: import com.mcpvp.battle.Battle;
 4: import com.mcpvp.common.chat.C;
 5: import com.mcpvp.common.command.CommandUtil;
 6: import org.bukkit.command.Command;
 7: import org.bukkit.command.CommandSender;
 8: import org.bukkit.entity.Player;
 9: 
10: public class QuickCommand extends Command {
11: 
12:     private final Battle battle;
13:     private final String message;
14:     private boolean sendToAll;
15:     private boolean includeLocation;
16: 
17:     protected QuickCommand(Battle battle, String name, String message) {
18:         super(name);
19:         this.battle = battle;
20:         this.message = message;
21:     }
22: 
23:     @Override
24:     public boolean execute(CommandSender sender, String label, String[] args) {
25:         String callout = this.battle.getGame().findClosestCallout(this.asPlayer(sender).getLocation())
26:             .map(c -> {
27:                 if (c.getConfig() != null) {
28:                     return " (near %s %s)".formatted(
29:                         this.battle.getGame().getTeamManager().getTeam(c.getConfig().getId()).getName(), c.getText()
30:                     );
31:                 }
32:                 return " (near %s)".formatted(c.getText());
33:             })
34:             .orElse("");
35: 
36:         this.asPlayer(sender).chat("%s%s/%s%s %s%s".formatted(
37:             this.sendToAll ? "!" : "",
38:             C.PURPLE,
39:             this.getName(),
40:             C.R,
41:             this.message,
42:             this.includeLocation ? callout : ""
43:         ));
44:         return false;
45:     }
46: 
47:     protected Player asPlayer(CommandSender sender) {
48:         if (!(sender instanceof Player)) {
49:             throw new IllegalStateException("Only players can execute this command.");
50:         }
51: 
52:         return ((Player) sender);
53:     }
54: 
55:     public QuickCommand all() {
56:         this.sendToAll = true;
57:         return this;
58:     }
59: 
60:     public QuickCommand loc() {
61:         this.includeLocation = true;
62:         return this;
63:     }
64: 
65:     public void register() {
66:         CommandUtil.getCommandMap().register("mcctf", this);
67:     }
68: 
69: }
</file>

<file path="src/main/java/com/mcpvp/battle/command/RespawnCommand.java">
 1: package com.mcpvp.battle.command;
 2: 
 3: import com.mcpvp.battle.Battle;
 4: import com.mcpvp.common.command.EasyCommand;
 5: import org.bukkit.command.CommandSender;
 6: 
 7: import java.util.List;
 8: 
 9: public class RespawnCommand extends EasyCommand {
10: 
11:     private final Battle battle;
12: 
13:     public RespawnCommand(Battle battle) {
14:         super("respawn");
15:         this.battle = battle;
16:     }
17: 
18:     @Override
19:     public boolean onCommand(CommandSender sender, String label, List<String> args) {
20:         this.battle.getGame().respawn(this.asPlayer(sender), false);
21:         return true;
22:     }
23: 
24: }
</file>

<file path="src/main/java/com/mcpvp/battle/command/YellCommand.java">
 1: package com.mcpvp.battle.command;
 2: 
 3: import com.mcpvp.common.command.EasyCommand;
 4: import org.bukkit.command.CommandSender;
 5: 
 6: import java.util.List;
 7: 
 8: public class YellCommand extends EasyCommand {
 9: 
10:     public YellCommand() {
11:         super("yell");
12:     }
13: 
14:     @Override
15:     public boolean onCommand(CommandSender sender, String label, List<String> args) {
16:         this.asPlayer(sender).chat("!" + String.join(" ", args));
17:         return true;
18:     }
19: 
20: }
</file>

<file path="src/main/java/com/mcpvp/battle/config/BattleGameConfig.java">
 1: package com.mcpvp.battle.config;
 2: 
 3: import com.mcpvp.battle.team.BattleTeam;
 4: import lombok.Data;
 5: import lombok.NoArgsConstructor;
 6: import lombok.NonNull;
 7: import org.bukkit.Location;
 8: 
 9: import java.util.HashSet;
10: import java.util.Set;
11: 
12: 
13: 
14: 
15: @Data
16: @NoArgsConstructor
17: public class BattleGameConfig {
18: 
19:     @NonNull
20:     private Location spawn;
21:     private Set<BattleTeamConfig> teamConfigs = new HashSet<>();
22:     private Set<BattleCallout> callouts = new HashSet<>();
23:     private Set<Location> restricted = new HashSet<>();
24:     private Integer timeOfDay;
25:     private int caps = 3;
26: 
27: 
28: 
29:     private int time = 15;
30: 
31:     public BattleTeamConfig getTeamConfig(int id) {
32:         return this.teamConfigs.stream().filter(c -> c.getId() == id).findAny().orElseThrow();
33:     }
34: 
35:     public BattleTeamConfig getTeamConfig(BattleTeam team) {
36:         return this.getTeamConfig(team.getId());
37:     }
38: 
39: }
</file>

<file path="src/main/java/com/mcpvp/battle/map/BattleWorldManager.java">
 1: package com.mcpvp.battle.map;
 2: 
 3: import com.mcpvp.battle.util.EmptyGenerator;
 4: import lombok.extern.log4j.Log4j2;
 5: import org.apache.commons.io.FileUtils;
 6: import org.bukkit.Bukkit;
 7: import org.bukkit.World;
 8: import org.bukkit.WorldCreator;
 9: import org.bukkit.WorldType;
10: 
11: import java.io.File;
12: import java.io.FileNotFoundException;
13: import java.io.IOException;
14: import java.nio.file.Files;
15: import java.nio.file.Path;
16: import java.util.stream.Stream;
17: 
18: 
19: 
20: 
21: 
22: @Log4j2
23: public class BattleWorldManager {
24: 
25:     private static final String WORLD_PREFIX = "ctf_game_world_";
26: 
27:     public static World create(File mapDir, int index) throws IOException {
28:         String worldName = WORLD_PREFIX + index;
29: 
30: 
31:         File worldDir = new File(Bukkit.getWorldContainer(), worldName);
32:         if (worldDir.exists()) {
33:             FileUtils.deleteDirectory(worldDir);
34:         }
35: 
36: 
37:         if (!mapDir.exists()) {
38:             throw new FileNotFoundException("Map file doesn't exist: " + mapDir);
39:         }
40: 
41: 
42:         FileUtils.copyDirectory(mapDir, worldDir);
43: 
44: 
45:         World world = new WorldCreator(worldName)
46:             .generateStructures(false)
47:             .generator(new EmptyGenerator())
48:             .environment(World.Environment.NORMAL)
49:             .type(WorldType.FLAT)
50:             .createWorld();
51: 
52: 
53:         initializeWorld(world);
54: 
55:         return world;
56:     }
57: 
58:     public static void cleanUpWorlds() throws IOException {
59:         try (Stream<Path> paths = Files.list(Bukkit.getWorldContainer().toPath())) {
60:             paths
61:                 .map(Path::toFile)
62:                 .filter(File::isDirectory)
63:                 .filter(file -> file.getName().startsWith(WORLD_PREFIX))
64:                 .forEach(f -> {
65:                     try {
66:                         FileUtils.deleteDirectory(f);
67:                     } catch (IOException e) {
68:                         log.warn("Failed to delete old map file at {}", f.getAbsolutePath(), e);
69:                     }
70:                 });
71:         }
72: 
73:     }
74: 
75:     private static void initializeWorld(World world) {
76:         world.setAutoSave(false);
77:         world.setGameRuleValue("naturalRegeneration", "false");
78:         world.setGameRuleValue("doDaylightCycle", "false");
79:         world.setGameRuleValue("mobGriefing", "false");
80:         world.setGameRuleValue("doFireTick", "false");
81:     }
82: 
83: }
</file>

<file path="src/main/java/com/mcpvp/battle/map/loader/BattleMapMetadataLoader.java">
  1: package com.mcpvp.battle.map.loader;
  2: 
  3: import com.mcpvp.battle.config.BattleCallout;
  4: import com.mcpvp.battle.config.BattleGameConfig;
  5: import com.mcpvp.battle.config.BattleTeamConfig;
  6: import com.mcpvp.battle.map.BattleMapData;
  7: import com.mcpvp.common.util.LookUtil;
  8: import org.bukkit.Location;
  9: import org.bukkit.Material;
 10: import org.bukkit.World;
 11: import org.bukkit.block.Block;
 12: import org.bukkit.block.BlockFace;
 13: import org.bukkit.block.Skull;
 14: import org.bukkit.util.Vector;
 15: 
 16: import java.util.Arrays;
 17: import java.util.List;
 18: import java.util.regex.Pattern;
 19: 
 20: public class BattleMapMetadataLoader implements BattleMapLoader {
 21: 
 22:     public BattleGameConfig parse(BattleMapData map, World world) {
 23:         BattleGameConfig builder = new BattleGameConfig();
 24:         BattleTeamConfig red = new BattleTeamConfig(1);
 25:         BattleTeamConfig blue = new BattleTeamConfig(2);
 26:         builder.getTeamConfigs().add(blue);
 27:         builder.getTeamConfigs().add(red);
 28: 
 29:         for (String line : map.getMetadata().split("\n")) {
 30:             if (line.isBlank() || line.startsWith("#")) {
 31:                 continue;
 32:             }
 33: 
 34:             String key = line.split("=")[0];
 35:             String value = line.split("=")[1];
 36:             String domain = key.split(Pattern.quote("."))[0];
 37:             String variable = key.split(Pattern.quote("."))[1];
 38: 
 39:             switch (domain) {
 40:                 case "Red", "Blue" -> {
 41:                     BattleTeamConfig config = domain.equals("Red") ? red : blue;
 42:                     switch (variable) {
 43:                         case "Respawn" -> {
 44:                             Location loc = this.findFirstSolidBlock(this.parseLocation(value, world))
 45:                                 .add(0.5, 1, 0.5);
 46:                             config.setSpawn(loc);
 47:                             builder.getCallouts().add(new BattleCallout(loc, config, "spawn"));
 48:                         }
 49:                         case "Chest" -> {
 50:                             Location loc = this.parseLocation(value, world).add(0.5, 1, 0.5);
 51:                             Block skull = this.parseLocation(value, world).getBlock().getRelative(BlockFace.UP);
 52: 
 53:                             if (skull.getState() instanceof Skull s) {
 54:                                 Location targ = skull.getRelative(s.getRotation()).getLocation();
 55:                                 Vector dir = LookUtil.lookAt(loc, targ).getDirection();
 56:                                 loc.setDirection(dir);
 57:                                 loc.getBlock().setType(Material.AIR);
 58:                             }
 59: 
 60:                             config.setFlag(loc);
 61:                             builder.getCallouts().add(new BattleCallout(loc, config, "flag"));
 62:                         }
 63:                         case "Face" -> {
 64:                             BlockFace face = switch (value) {
 65:                                 case "n" -> BlockFace.NORTH;
 66:                                 case "e" -> BlockFace.EAST;
 67:                                 case "s" -> BlockFace.SOUTH;
 68:                                 case "w" -> BlockFace.WEST;
 69:                                 default -> null;
 70:                             };
 71:                             if (face != null) {
 72:                                 config.setSpawn(LookUtil.lookAt(config.getSpawn(), config.getSpawn().getBlock().getRelative(face).getLocation().add(0.5, 0, 0.5)));
 73:                             }
 74:                         }
 75:                     }
 76:                 }
 77:                 case "CTF" -> {
 78:                     switch (variable) {
 79:                         case "CapturesToWin" -> builder.setCaps(Integer.parseInt(value));
 80:                         case "Spawn" -> {
 81:                             Location location = this.parseLocation(value, world);
 82:                             int highestBlockYAt = world.getHighestBlockYAt(location.getBlockX(), location.getBlockZ());
 83:                             location.setY(highestBlockYAt);
 84:                             builder.setSpawn(location.add(0.5, 0, 0.5));
 85:                         }
 86:                         case "Time" -> builder.setTimeOfDay(Integer.parseInt(value));
 87:                     }
 88:                 }
 89:             }
 90:         }
 91: 
 92:         return builder;
 93:     }
 94: 
 95:     private Location findFirstSolidBlock(Location location) {
 96:         if (location.getY() == 0) {
 97:             throw new IllegalStateException(
 98:                 "Could not find a solid block at the spawn location"
 99:             );
100:         }
101: 
102:         if (location.getBlock().getType().isSolid()) {
103:             return location;
104:         }
105: 
106:         return this.findFirstSolidBlock(location.subtract(0, 1, 0));
107:     }
108: 
109:     private Location parseLocation(String string, World world) {
110:         List<Integer> parts = Arrays.stream(string.trim().split(",")).mapToInt(Integer::parseInt).boxed().toList();
111:         return world.getBlockAt(parts.get(0), parts.get(1), parts.get(2)).getLocation();
112:     }
113: 
114: }
</file>

<file path="src/main/java/com/mcpvp/battle/map/manager/MergingMapManager.java">
  1: package com.mcpvp.battle.map.manager;
  2: 
  3: import com.fasterxml.jackson.core.type.TypeReference;
  4: import com.fasterxml.jackson.databind.ObjectMapper;
  5: import com.mcpvp.battle.BattlePlugin;
  6: import com.mcpvp.battle.map.BattleMapData;
  7: import com.mcpvp.battle.map.repo.BattleMapSource;
  8: import com.mcpvp.battle.options.BattleOptionsInput;
  9: import lombok.AllArgsConstructor;
 10: import org.apache.commons.io.FileUtils;
 11: 
 12: import java.io.File;
 13: import java.io.IOException;
 14: import java.util.ArrayList;
 15: import java.util.Collections;
 16: import java.util.List;
 17: 
 18: @AllArgsConstructor
 19: public class MergingMapManager implements BattleMapManager {
 20: 
 21:     private final BattlePlugin plugin;
 22:     private final BattleOptionsInput.MapOptions mapOptions;
 23:     private final List<BattleMapSource> repos;
 24: 
 25:     @Override
 26:     public List<BattleMapData> getEnabled() {
 27:         return this.repos.stream().flatMap(repo -> repo.getFunctional().stream()).filter(m ->
 28:             this.mapOptions.getCategories().getOrDefault(m.getCategory(), true)
 29:         ).filter(m ->
 30:             !this.mapOptions.getDisable().contains(m.getId())
 31:         ).toList();
 32:     }
 33: 
 34:     @Override
 35:     public boolean isMap(int id) {
 36:         return this.repos.stream().anyMatch(repo ->
 37:             repo.getFunctional().stream().anyMatch(d -> d.getId() == id)
 38:         );
 39:     }
 40: 
 41:     @Override
 42:     public List<Integer> pickMaps(int games) {
 43:         List<BattleMapData> eligible = new ArrayList<>();
 44:         this.repos.forEach(repo -> eligible.addAll(this.getEnabled()));
 45:         Collections.shuffle(eligible);
 46: 
 47:         List<Integer> maps = new ArrayList<>();
 48: 
 49:         for (int i = 0; i < games; i++) {
 50:             maps.add(eligible.get(i % eligible.size()).getId());
 51:         }
 52: 
 53:         return maps;
 54:     }
 55: 
 56:     @Override
 57:     public BattleMapData loadMap(int id) {
 58:         return this.repos.stream()
 59:             .flatMap(repo -> repo.getFunctional().stream())
 60:             .filter(m -> m.getId() == id)
 61:             .findFirst()
 62:             .orElseThrow(() -> new IllegalStateException("Could not find the requested map: " + id));
 63:     }
 64: 
 65:     @Override
 66:     public List<BattleMapData> loadMaps(int games) {
 67:         return this.pickMaps(games).stream().map(this::loadMap).toList();
 68:     }
 69: 
 70:     @Override
 71:     public File getWorldData(BattleMapData map) {
 72:         return this.repos.stream()
 73:             .filter(repo -> repo.getAll().contains(map))
 74:             .findFirst()
 75:             .map(repo -> repo.getWorldData(map))
 76:             .orElseThrow(() -> new IllegalStateException("No world data found for map: " + map));
 77:     }
 78: 
 79:     @Override
 80:     public void setOverride(List<Integer> ids) {
 81:         File file = new File(this.plugin.getDataFolder(), "override_maps.json");
 82:         try {
 83:             FileUtils.write(file, new ObjectMapper().writeValueAsString(ids));
 84:         } catch (IOException e) {
 85:             throw new RuntimeException("Unable to create map override", e);
 86:         }
 87:     }
 88: 
 89:     @Override
 90:     public void clearOverride() {
 91:         if (!new File(this.plugin.getDataFolder(), "override_maps.json").delete()) {
 92:             throw new RuntimeException("Failed to remove the override_maps.json");
 93:         }
 94:     }
 95: 
 96:     @Override
 97:     public List<BattleMapData> getOverride() {
 98:         File file = new File(this.plugin.getDataFolder(), "override_maps.json");
 99:         if (!file.exists()) {
100:             return Collections.emptyList();
101:         }
102:         try {
103:             List<Integer> ids = new ObjectMapper().readValue(file, new TypeReference<>() {
104:             });
105:             return ids.stream().map(this::loadMap).toList();
106:         } catch (IOException e) {
107:             throw new RuntimeException("Failed to read the override_maps.json file", e);
108:         }
109:     }
110: 
111: }
</file>

<file path="src/main/java/com/mcpvp/battle/team/BattleTeamManager.java">
 1: package com.mcpvp.battle.team;
 2: 
 3: import com.mcpvp.battle.config.BattleTeamConfig;
 4: import com.mcpvp.battle.event.PlayerJoinTeamEvent;
 5: import com.mcpvp.battle.event.PlayerLeaveTeamEvent;
 6: import com.mcpvp.common.chat.Colors;
 7: import lombok.Getter;
 8: import lombok.RequiredArgsConstructor;
 9: import org.bukkit.entity.Player;
10: 
11: import javax.annotation.Nullable;
12: import java.util.*;
13: import java.util.stream.Collectors;
14: 
15: 
16: 
17: 
18: @RequiredArgsConstructor
19: public class BattleTeamManager {
20: 
21:     private static final Random RANDOM = new Random();
22: 
23:     @Getter
24:     private final List<BattleTeam> teams = new ArrayList<>();
25: 
26:     public void createDefaultTeams(Set<BattleTeamConfig> configs) {
27: 
28: 
29:         Map<Integer, BattleTeamConfig> configById = configs.stream().collect(
30:             Collectors.toMap(BattleTeamConfig::getId, e -> e)
31:         );
32: 
33:         BattleTeam red = new BattleTeam(1, "Red", Colors.RED, configById.get(1));
34:         BattleTeam blue = new BattleTeam(2, "Blue", Colors.BLUE, configById.get(2));
35:         this.teams.add(red);
36:         this.teams.add(blue);
37:     }
38: 
39:     public void setTeam(Player player, @Nullable BattleTeam team) {
40: 
41:         for (BattleTeam battleTeam : this.getTeams()) {
42:             if (battleTeam.contains(player)) {
43:                 battleTeam.remove(player);
44:                 new PlayerLeaveTeamEvent(player, battleTeam).call();
45:             }
46:         }
47: 
48: 
49:         if (team != null && !team.contains(player)) {
50:             team.add(player);
51:             new PlayerJoinTeamEvent(player, team).call();
52:         }
53:     }
54: 
55:     public BattleTeam getTeam(Player player) {
56:         return this.getTeams().stream().filter(bt -> bt.contains(player)).findFirst().orElse(null);
57:     }
58: 
59:     public BattleTeam getTeam(int id) {
60:         return this.getTeams().stream().filter(bt -> bt.getId() == id).findFirst().orElseThrow(() ->
61:             new IllegalStateException("No team found for id " + id)
62:         );
63:     }
64: 
65:     public BattleTeam selectAutoTeam() {
66:         if (this.getTeams().stream().map(t -> t.getPlayers().size()).distinct().count() == 1) {
67: 
68:             return this.getTeams().get(RANDOM.nextInt(this.getTeams().size()));
69:         } else {
70: 
71:             return this.getTeams().stream()
72:                 .min(Comparator.comparingInt(t -> t.getPlayers().size()))
73:                 .orElse(this.getTeams().get(RANDOM.nextInt(this.getTeams().size())));
74:         }
75:     }
76: 
77:     public BattleTeam getNext(BattleTeam team) {
78:         return this.teams.get((this.teams.indexOf(team) + 1) % this.teams.size());
79:     }
80: 
81:     public boolean isSameTeam(Player first, Player second) {
82:         return this.getTeam(first) == this.getTeam(second);
83:     }
84: 
85:     public Map<BattleTeam, Set<Player>> getPlayerMap() {
86:         return this.teams.stream().collect(Collectors.toMap(e -> e, BattleTeam::getPlayers));
87:     }
88: 
89: }
</file>

<file path="src/main/java/com/mcpvp/common/EasyLifecycle.java">
 1: package com.mcpvp.common;
 2: 
 3: import com.mcpvp.common.event.EasyListener;
 4: import org.bukkit.entity.Entity;
 5: import org.bukkit.entity.Player;
 6: import org.bukkit.scheduler.BukkitTask;
 7: 
 8: import java.util.HashSet;
 9: import java.util.Set;
10: 
11: 
12: 
13: 
14: 
15: public class EasyLifecycle {
16: 
17:     private final Set<EasyListener> listeners = new HashSet<>();
18:     private final Set<BukkitTask> tasks = new HashSet<>();
19:     private final Set<EasyLifecycle> lifecycles = new HashSet<>();
20:     private final Set<Entity> entities = new HashSet<>();
21: 
22: 
23: 
24: 
25: 
26: 
27:     protected void attach(EasyListener listener) {
28:         this.listeners.add(listener);
29:         listener.register();
30:     }
31: 
32: 
33: 
34: 
35: 
36: 
37:     protected void attach(BukkitTask task) {
38:         this.tasks.add(task);
39:     }
40: 
41: 
42: 
43: 
44: 
45: 
46:     protected void attach(EasyLifecycle lifecycle) {
47:         this.lifecycles.add(lifecycle);
48:     }
49: 
50: 
51: 
52: 
53: 
54: 
55:     protected void attach(Entity entity) {
56:         if (entity instanceof Player) {
57:             throw new IllegalArgumentException("Player entity cannot be attached");
58:         }
59: 
60:         this.entities.add(entity);
61:     }
62: 
63: 
64: 
65: 
66:     public void shutdown() {
67:         this.listeners.forEach(EasyListener::unregister);
68:         this.tasks.forEach(BukkitTask::cancel);
69:         this.lifecycles.forEach(EasyLifecycle::shutdown);
70:         this.entities.forEach(Entity::remove);
71:     }
72: 
73: }
</file>

<file path="src/main/java/com/mcpvp/common/InteractiveProjectile.java">
 1: package com.mcpvp.common;
 2: 
 3: import com.mcpvp.common.event.EasyListener;
 4: import com.mcpvp.common.event.TickEvent;
 5: import lombok.Getter;
 6: import lombok.RequiredArgsConstructor;
 7: import org.bukkit.entity.Player;
 8: import org.bukkit.entity.Projectile;
 9: import org.bukkit.event.EventHandler;
10: import org.bukkit.event.entity.EntityDamageByEntityEvent;
11: import org.bukkit.event.entity.ProjectileHitEvent;
12: import org.bukkit.plugin.Plugin;
13: 
14: import java.util.function.Consumer;
15: 
16: @RequiredArgsConstructor
17: public class InteractiveProjectile implements EasyListener {
18: 
19:     @Getter
20:     private final Plugin plugin;
21:     private final Projectile projectile;
22: 
23:     private boolean singleEventOnly;
24:     private Consumer<Player> hitPlayerConsumer;
25:     private Consumer<EntityDamageByEntityEvent> damageEventConsumer;
26:     private Consumer<ProjectileHitEvent> hitEventConsumer;
27:     private Runnable deathRunnable;
28: 
29:     public InteractiveProjectile singleEventOnly() {
30:         this.singleEventOnly = true;
31:         return this;
32:     }
33: 
34:     public InteractiveProjectile onHitPlayer(Consumer<Player> consumer) {
35:         this.hitPlayerConsumer = consumer;
36:         return this;
37:     }
38: 
39:     public InteractiveProjectile onDamageEvent(Consumer<EntityDamageByEntityEvent> consumer) {
40:         this.damageEventConsumer = consumer;
41:         return this;
42:     }
43: 
44:     public InteractiveProjectile onHitEvent(Consumer<ProjectileHitEvent> consumer) {
45:         this.hitEventConsumer = consumer;
46:         return this;
47:     }
48: 
49:     public InteractiveProjectile onDeath(Runnable runnable) {
50:         this.deathRunnable = runnable;
51:         return this;
52:     }
53: 
54:     @EventHandler
55:     private void onEntityDamageByProjectile(EntityDamageByEntityEvent event) {
56:         if (event.getDamager() == this.projectile) {
57:             if (event.getEntity() instanceof Player hit && this.hitPlayerConsumer != null) {
58:                 this.hitPlayerConsumer.accept(hit);
59:                 if (this.singleEventOnly) {
60:                     this.unregister();
61:                 }
62:             } else if (this.damageEventConsumer != null) {
63:                 this.damageEventConsumer.accept(event);
64:                 if (this.singleEventOnly) {
65:                     this.unregister();
66:                 }
67:             }
68:         }
69:     }
70: 
71:     @EventHandler
72:     private void onProjectileHitEvent(ProjectileHitEvent event) {
73:         if (event.getEntity() == this.projectile && this.hitEventConsumer != null) {
74:             this.hitEventConsumer.accept(event);
75: 
76:             if (this.singleEventOnly) {
77:                 this.unregister();
78:             }
79:         }
80:     }
81: 
82:     @EventHandler
83:     private void onTick(TickEvent event) {
84: 
85:         if (this.projectile.isDead() || !this.projectile.isValid()) {
86:             if (this.deathRunnable != null) {
87:                 this.deathRunnable.run();
88:             }
89:             this.unregister();
90:         }
91:     }
92: 
93: }
</file>

<file path="src/main/java/com/mcpvp/common/kit/KitItem.java">
  1: package com.mcpvp.common.kit;
  2: 
  3: import com.mcpvp.common.item.InteractiveItem;
  4: import com.mcpvp.common.item.ItemBuilder;
  5: import lombok.Getter;
  6: import lombok.ToString;
  7: import org.bukkit.Material;
  8: import org.bukkit.inventory.Inventory;
  9: import org.bukkit.inventory.ItemStack;
 10: 
 11: import java.util.function.UnaryOperator;
 12: 
 13: 
 14: 
 15: 
 16: @ToString
 17: public class KitItem extends InteractiveItem {
 18: 
 19:     protected final Kit kit;
 20:     @Getter
 21:     private final ItemStack original;
 22:     @Getter
 23:     private final boolean restorable;
 24: 
 25:     public KitItem(Kit kit, ItemStack itemStack, boolean restorable) {
 26:         super(kit.getPlugin(), itemStack);
 27:         this.kit = kit;
 28:         this.original = this.getItem().clone();
 29:         this.restorable = restorable;
 30:     }
 31: 
 32:     public KitItem(Kit kit, ItemStack itemStack) {
 33:         this(kit, itemStack, false);
 34:     }
 35: 
 36: 
 37: 
 38: 
 39: 
 40: 
 41: 
 42:     public void decrement(boolean placeholder) {
 43:         if (this.getItem().getAmount() == 1 && placeholder) {
 44:             this.setPlaceholder();
 45:         } else {
 46:             this.modify(builder -> builder.amount(this.getItem().getAmount() - 1));
 47:         }
 48:     }
 49: 
 50: 
 51: 
 52: 
 53:     public void setPlaceholder() {
 54:         this.modify(ib ->
 55:             ib.type(Material.STAINED_GLASS_PANE).durability(0)
 56:         );
 57:     }
 58: 
 59: 
 60: 
 61: 
 62: 
 63: 
 64:     public boolean isPlaceholder() {
 65:         return this.getItem().getType() == Material.STAINED_GLASS_PANE;
 66:     }
 67: 
 68: 
 69: 
 70: 
 71: 
 72: 
 73: 
 74:     public void increment(int max) {
 75:         if (this.isPlaceholder()) {
 76:             this.restore();
 77:             this.modify(builder -> builder.amount(1));
 78:         } else if (this.getItem().getAmount() < max) {
 79:             this.modify(builder -> builder.amount(this.getItem().getAmount() + 1));
 80:         }
 81:     }
 82: 
 83: 
 84: 
 85: 
 86:     public void restore() {
 87:         this.setItem(this.getOriginal().clone());
 88:         this.update(this.kit.getPlayer().getInventory());
 89:     }
 90: 
 91:     @Override
 92:     public void update(Inventory inv) {
 93:         super.update(inv);
 94: 
 95: 
 96: 
 97:         if (this.isItem(this.kit.getPlayer().getItemInHand())) {
 98:             this.kit.getPlayer().setItemInHand(this.getItem());
 99:             this.kit.getPlayer().updateInventory();
100:         }
101:     }
102: 
103:     public void modify(UnaryOperator<ItemBuilder> editor) {
104:         editor.apply(new ItemBuilder(this.getItem(), false));
105:         this.update(this.kit.getPlayer().getInventory());
106:     }
107: 
108: }
</file>

<file path="src/main/java/com/mcpvp/common/kit/KitManager.java">
 1: package com.mcpvp.common.kit;
 2: 
 3: import lombok.RequiredArgsConstructor;
 4: import lombok.extern.log4j.Log4j2;
 5: import org.bukkit.entity.Player;
 6: import org.bukkit.plugin.Plugin;
 7: 
 8: import javax.annotation.Nullable;
 9: import java.util.Collections;
10: import java.util.List;
11: import java.util.Map;
12: import java.util.Optional;
13: import java.util.concurrent.ConcurrentHashMap;
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: @Log4j2
27: @RequiredArgsConstructor
28: public class KitManager {
29: 
30:     private final Plugin plugin;
31:     private final Map<Player, KitDefinition> selected = new ConcurrentHashMap<>();
32:     private final Map<Player, Kit> active = new ConcurrentHashMap<>();
33: 
34:     public List<KitDefinition> getKitDefinitions() {
35:         return Collections.emptyList();
36:     }
37: 
38:     public KitDefinition getKitDefinition(String name) {
39:         return this.getKitDefinitions().stream().filter(k -> k.getName().equalsIgnoreCase(name)).findFirst().orElse(null);
40:     }
41: 
42:     public void setSelected(Player player, KitDefinition definition, boolean force) {
43:         this.setSelected(player, definition, force, true);
44:     }
45: 
46:     public KitAttemptSelectEvent setSelected(
47:         Player player, KitDefinition definition, boolean force, boolean respawn
48:     ) {
49: 
50:         KitAttemptSelectEvent kitAttemptSelectEvent = new KitAttemptSelectEvent(player, definition);
51:         if (!kitAttemptSelectEvent.callIsCancelled() || force) {
52:             this.selected.put(player, definition);
53:             new KitSelectedEvent(player, definition, respawn).call();
54:             return kitAttemptSelectEvent;
55:         }
56: 
57:         return kitAttemptSelectEvent;
58:     }
59: 
60:     public boolean isSelected(Player player, KitDefinition definition) {
61:         return this.selected.containsKey(player) && this.selected.get(player).equals(definition);
62:     }
63: 
64:     @Nullable
65:     public KitDefinition getSelected(Player player) {
66:         return this.selected.get(player);
67:     }
68: 
69:     public void createSelected(Player player) {
70:         KitDefinition selected = this.getSelected(player);
71:         if (selected == null) {
72:             return;
73:         }
74: 
75:         log.info("Creating selected {} for {}", selected, player.getName());
76: 
77: 
78:         if (this.active.containsKey(player)) {
79:             this.active.get(player).shutdown();
80:         }
81: 
82:         Kit created = selected.create(this.plugin, player);
83:         this.active.put(player, created);
84:     }
85: 
86:     @Nullable
87:     public Kit get(Player player) {
88:         return this.active.get(player);
89:     }
90: 
91:     public boolean isPlaying(Player player, Class<? extends Kit> type) {
92:         return Optional.ofNullable(this.get(player)).map(k -> k.getClass().equals(type)).orElse(false);
93:     }
94: 
95: }
</file>

<file path="src/main/java/com/mcpvp/common/task/DrainExpBarTask.java">
 1: package com.mcpvp.common.task;
 2: 
 3: import com.mcpvp.common.time.Duration;
 4: import org.bukkit.entity.Player;
 5: import org.bukkit.plugin.Plugin;
 6: import org.bukkit.scheduler.BukkitRunnable;
 7: import org.bukkit.scheduler.BukkitTask;
 8: 
 9: public final class DrainExpBarTask extends BukkitRunnable implements ExpBarTask {
10: 
11:     private final Player player;
12:     private final float perTick;
13:     private final int runsRequired;
14:     private int runs = 0;
15: 
16:     public DrainExpBarTask(Player player, Duration duration) {
17:         this.player = player;
18:         this.perTick = player.getExp() / duration.ticks();
19:         this.runsRequired = duration.ticks();
20:     }
21: 
22:     @Override
23:     public void run() {
24:         this.player.setExp(Math.max(this.player.getExp() - this.perTick, 0f));
25: 
26:         if (this.player.getExp() == 1f || this.runs++ == this.runsRequired) {
27:             this.cancel();
28:         }
29:     }
30: 
31:     public BukkitTask schedule(Plugin plugin) {
32:         return this.runTaskTimer(plugin, 0, 1);
33:     }
34: 
35: }
</file>

<file path="src/main/java/com/mcpvp/common/task/FillExpBarTask.java">
 1: package com.mcpvp.common.task;
 2: 
 3: import com.mcpvp.common.time.Duration;
 4: import org.bukkit.entity.Player;
 5: import org.bukkit.plugin.Plugin;
 6: import org.bukkit.scheduler.BukkitRunnable;
 7: import org.bukkit.scheduler.BukkitTask;
 8: 
 9: public final class FillExpBarTask extends BukkitRunnable implements ExpBarTask {
10: 
11:     private final Player player;
12:     private final float perTick;
13:     private final int runsRequired;
14:     private int runs = 0;
15: 
16:     public FillExpBarTask(Player player, Duration duration) {
17:         this.player = player;
18:         this.perTick = (1f - player.getExp()) / duration.ticks();
19:         this.runsRequired = duration.ticks();
20:     }
21: 
22:     @Override
23:     public void run() {
24:         this.player.setExp(Math.min(this.player.getExp() + this.perTick, 1f));
25: 
26:         if (this.player.getExp() == 1f || this.runs++ == this.runsRequired) {
27:             this.cancel();
28:         }
29:     }
30: 
31:     public BukkitTask schedule(Plugin plugin) {
32:         return this.runTaskTimer(plugin, 0, 1);
33:     }
34: 
35: }
</file>

<file path="src/main/java/com/mcpvp/common/time/Duration.java">
  1: package com.mcpvp.common.time;
  2: 
  3: import lombok.Getter;
  4: 
  5: import java.io.Serializable;
  6: import java.time.LocalDateTime;
  7: import java.time.ZoneOffset;
  8: import java.util.Date;
  9: import java.util.LinkedList;
 10: import java.util.List;
 11: import java.util.regex.Matcher;
 12: import java.util.regex.Pattern;
 13: 
 14: 
 15: 
 16: 
 17: 
 18: @SuppressWarnings("unused")
 19: public class Duration implements Serializable {
 20: 
 21:     public static final Duration ZERO = new Duration(0, Unit.MILLISECOND);
 22: 
 23:     public enum Unit {
 24:         MILLISECOND(1, "ms"),
 25:         TICK(50, "t"),
 26:         SECOND(1000, "s"),
 27:         MINUTE(60000, "m"),
 28:         HOUR(3600000, "h");
 29: 
 30:         @Getter
 31:         final long milliseconds;
 32:         final String symbol;
 33:         final Pattern pattern;
 34: 
 35:         Unit(long milliseconds, String symbol) {
 36:             this.milliseconds = milliseconds;
 37:             this.symbol = symbol;
 38:             this.pattern = Pattern.compile("(\\d+)" + symbol + "(?:\\s|$|\\d)");
 39:         }
 40: 
 41:     }
 42: 
 43:     private final long milliseconds;
 44: 
 45:     public Duration(long value, Unit unit) {
 46:         this.milliseconds = (value * unit.getMilliseconds());
 47:     }
 48: 
 49:     public Duration(double value, Unit unit) {
 50:         this.milliseconds = (long) (value * unit.getMilliseconds());
 51:     }
 52: 
 53:     public Duration(Date startTime, Date endTime) {
 54:         this.milliseconds = endTime.getTime() - startTime.getTime();
 55:     }
 56: 
 57:     public long toMilliseconds() {
 58:         return this.milliseconds;
 59:     }
 60: 
 61:     public long ms() {
 62:         return this.toMilliseconds();
 63:     }
 64: 
 65:     public int toTicks() {
 66:         return (int) this.getValue(Unit.TICK);
 67:     }
 68: 
 69:     public int ticks() {
 70:         return this.toTicks();
 71:     }
 72: 
 73:     public long toSeconds() {
 74:         return this.getValue(Unit.SECOND);
 75:     }
 76: 
 77:     public long seconds() {
 78:         return this.toSeconds();
 79:     }
 80: 
 81:     public long toMinutes() {
 82:         return this.getValue(Unit.MINUTE);
 83:     }
 84: 
 85:     public long mins() {
 86:         return this.toMinutes();
 87:     }
 88: 
 89:     public long toHours() {
 90:         return this.getValue(Unit.HOUR);
 91:     }
 92: 
 93:     public double toHoursExact() {
 94:         return (double) this.ms() / Unit.HOUR.getMilliseconds();
 95:     }
 96: 
 97:     public long hrs() {
 98:         return this.toHours();
 99:     }
100: 
101:     public long getValue(Unit unit) {
102:         return this.toMilliseconds() / unit.getMilliseconds();
103:     }
104: 
105:     public String formatText() {
106:         return this.formatText(Unit.SECOND);
107:     }
108: 
109:     public String formatText(Unit smallest) {
110:         long ms = this.milliseconds;
111:         List<String> strings = new LinkedList<>();
112: 
113:         for (int i = Unit.values().length - 1; i != -1 && ms > 0; i--) {
114:             if (smallest != null && i < smallest.ordinal()) {
115:                 continue;
116:             }
117: 
118:             Unit u = Unit.values()[i];
119:             long v = ms(ms).getValue(u);
120: 
121:             if (v != 0) {
122:                 strings.add(v + u.symbol);
123:                 ms -= new Duration(v, u).ms();
124:             }
125:         }
126: 
127:         return String.join(" ", strings);
128:     }
129: 
130: 
131: 
132: 
133: 
134: 
135:     public Duration add(Duration duration) {
136:         return Duration.milliseconds(this.toMilliseconds() + duration.toMilliseconds());
137:     }
138: 
139: 
140: 
141: 
142: 
143: 
144:     public Duration subtract(Duration duration) {
145:         return Duration.milliseconds(this.toMilliseconds() - duration.toMilliseconds());
146:     }
147: 
148: 
149: 
150: 
151: 
152: 
153:     public Duration multiply(Duration duration) {
154:         return Duration.milliseconds(this.toMilliseconds() * duration.toMilliseconds());
155:     }
156: 
157: 
158: 
159: 
160: 
161: 
162:     public Duration divide(Duration duration) {
163:         return Duration.milliseconds(this.toMilliseconds() / duration.toMilliseconds());
164:     }
165: 
166:     public java.time.Duration toJava() {
167:         return java.time.Duration.ofMillis(this.milliseconds);
168:     }
169: 
170:     public static Duration milliseconds(double milliseconds) {
171:         return new Duration(milliseconds, Unit.MILLISECOND);
172:     }
173: 
174:     public static Duration milliseconds(long milliseconds) {
175:         return new Duration(milliseconds, Unit.MILLISECOND);
176:     }
177: 
178:     public static Duration ms(double milliseconds) {
179:         return milliseconds(milliseconds);
180:     }
181: 
182:     public static Duration ms(long milliseconds) {
183:         return milliseconds(milliseconds);
184:     }
185: 
186:     public static Duration ticks(double ticks) {
187:         return new Duration(ticks, Unit.TICK);
188:     }
189: 
190:     public static Duration ticks(long ticks) {
191:         return new Duration(ticks, Unit.TICK);
192:     }
193: 
194:     public static Duration t(double ticks) {
195:         return ticks(ticks);
196:     }
197: 
198:     public static Duration t(long ticks) {
199:         return ticks(ticks);
200:     }
201: 
202:     public static Duration seconds(double seconds) {
203:         return new Duration(seconds, Unit.SECOND);
204:     }
205: 
206:     public static Duration seconds(long seconds) {
207:         return new Duration(seconds, Unit.SECOND);
208:     }
209: 
210:     public static Duration secs(double seconds) {
211:         return seconds(seconds);
212:     }
213: 
214:     public static Duration secs(long seconds) {
215:         return seconds(seconds);
216:     }
217: 
218:     public static Duration minutes(double minutes) {
219:         return new Duration(minutes, Unit.MINUTE);
220:     }
221: 
222:     public static Duration minutes(long minutes) {
223:         return new Duration(minutes, Unit.MINUTE);
224:     }
225: 
226:     public static Duration mins(double minutes) {
227:         return minutes(minutes);
228:     }
229: 
230:     public static Duration mins(long minutes) {
231:         return minutes(minutes);
232:     }
233: 
234:     public static Duration hours(double hours) {
235:         return new Duration(hours, Unit.HOUR);
236:     }
237: 
238:     public static Duration hours(long hours) {
239:         return new Duration(hours, Unit.HOUR);
240:     }
241: 
242:     public static Duration hrs(double hours) {
243:         return hours(hours);
244:     }
245: 
246:     public static Duration hrs(long hours) {
247:         return hours(hours);
248:     }
249: 
250: 
251: 
252: 
253: 
254: 
255:     public static Duration since(LocalDateTime time) {
256:         long t = time.toInstant(ZoneOffset.UTC).toEpochMilli();
257:         if (t > System.currentTimeMillis()) {
258:             return ms(t - System.currentTimeMillis());
259:         }
260: 
261:         return ms(System.currentTimeMillis() - t);
262:     }
263: 
264: 
265: 
266: 
267: 
268: 
269:     public static Duration since(long ms) {
270:         return ms(System.currentTimeMillis() - ms);
271:     }
272: 
273: 
274: 
275: 
276: 
277: 
278: 
279: 
280:     public static Duration valueOf(String str) {
281:         Duration dur = Duration.ms(0);
282: 
283:         for (Unit u : Unit.values()) {
284:             Matcher m = u.pattern.matcher(str);
285: 
286:             while (m.find()) {
287:                 dur = dur.add(new Duration(Integer.parseInt(m.group().replaceAll(m.pattern().pattern(), "$1").trim()), u));
288:             }
289:         }
290: 
291:         return dur;
292:     }
293: 
294:     @Override
295:     public boolean equals(Object o) {
296:         return o instanceof Duration && this.toMilliseconds() == ((Duration) o).toMilliseconds();
297:     }
298: 
299:     @Override
300:     public int hashCode() {
301:         return Long.valueOf(this.toMilliseconds()).hashCode();
302:     }
303: 
304:     @Override
305:     public String toString() {
306:         return this.formatText();
307:     }
308: 
309: }
</file>

<file path="src/main/java/com/mcpvp/common/util/PlayerUtil.java">
 1: package com.mcpvp.common.util;
 2: 
 3: import net.minecraft.server.v1_8_R3.EntityPlayer;
 4: import org.bukkit.entity.Player;
 5: import org.bukkit.inventory.ItemStack;
 6: import org.bukkit.potion.PotionEffect;
 7: import org.bukkit.util.Vector;
 8: 
 9: public class PlayerUtil {
10: 
11: 
12: 
13: 
14: 
15: 
16:     public static void reset(Player player) {
17:         PlayerUtil.setAbsorptionHearts(player, 0);
18:         player.setHealth(player.getMaxHealth());
19:         player.setFireTicks(0);
20:         player.setLevel(0);
21:         player.setExp(1.0f);
22:         player.getInventory().clear();
23:         player.getInventory().setArmorContents(new ItemStack[4]);
24:         player.getActivePotionEffects().stream().map(PotionEffect::getType).forEach(player::removePotionEffect);
25:         player.setHealth(player.getMaxHealth());
26:         player.setVelocity(new Vector());
27:     }
28: 
29:     public static float getAbsorptionHearts(Player player) {
30:         return asCraftPlayer(player).getAbsorptionHearts();
31:     }
32: 
33:     public static void setAbsorptionHearts(Player player, float hearts) {
34:         asCraftPlayer(player).setAbsorptionHearts(hearts);
35:     }
36: 
37:     public static EntityPlayer asCraftPlayer(Player player) {
38:         return ((org.bukkit.craftbukkit.v1_8_R3.entity.CraftPlayer) player).getHandle();
39:     }
40: 
41: }
</file>

<file path="src/main/java/com/mcpvp/battle/map/BattleMapTester.java">
  1: package com.mcpvp.battle.map;
  2: 
  3: import com.fasterxml.jackson.databind.ObjectMapper;
  4: import com.mcpvp.battle.config.BattleGameConfig;
  5: import com.mcpvp.battle.config.BattleTeamConfig;
  6: import com.mcpvp.battle.map.loader.BattleMapLoader;
  7: import com.mcpvp.battle.map.loader.BattleMapMetadataLoader;
  8: import com.mcpvp.battle.map.loader.BattleMapSignLoader;
  9: import com.mcpvp.battle.map.manager.BattleMapManager;
 10: import com.mcpvp.battle.map.repo.BattleMapSource;
 11: import com.mcpvp.battle.options.BattleOptionsInput;
 12: import lombok.Data;
 13: import lombok.RequiredArgsConstructor;
 14: import lombok.SneakyThrows;
 15: import lombok.extern.log4j.Log4j2;
 16: import org.bukkit.Bukkit;
 17: import org.bukkit.World;
 18: 
 19: import java.io.File;
 20: import java.io.FileNotFoundException;
 21: import java.io.IOException;
 22: import java.util.ArrayList;
 23: import java.util.HashMap;
 24: import java.util.List;
 25: import java.util.Map;
 26: 
 27: @Log4j2
 28: @RequiredArgsConstructor
 29: public class BattleMapTester {
 30: 
 31:     private final ObjectMapper mapper;
 32: 
 33:     @SneakyThrows
 34:     public void run(
 35:         BattleOptionsInput.MapTesterOptions testOptions,
 36:         BattleMapSource mapSource,
 37:         BattleMapManager mapManager
 38:     ) {
 39:         File testOutputDir = new File(testOptions.getOutputDir());
 40:         File testOutputFile = new File(testOutputDir, "test_progress_" + testOptions.getRunId() + ".json");
 41: 
 42:         MapTestResults results = this.loadExistingResults(testOutputFile);
 43: 
 44:         List<BattleMapData> untested = mapSource.getAll().stream()
 45:             .filter(data -> !results.errors.containsKey(data.getId()))
 46:             .toList();
 47:         log.info("Found {} untested maps. Testing will begin in ten seconds...", untested.size());
 48: 
 49:         Thread.sleep(10_000);
 50: 
 51:         for (int i = 0; i < untested.size(); i++) {
 52:             if ((i + 1) % 500 == 0) {
 53:                 this.saveResults(testOutputFile, results);
 54:                 log.info("Stopping tester to avoid memory problems. Restart the server to continue testing.");
 55:                 Bukkit.shutdown();
 56:                 return;
 57:             }
 58: 
 59:             BattleMapData battleMapData = untested.get(i);
 60:             try {
 61:                 log.info("Processing map {}", battleMapData);
 62:                 List<String> errors = this.test(
 63:                     mapManager.getWorldData(battleMapData),
 64:                     battleMapData,
 65:                     i
 66:                 );
 67:                 results.errors.put(battleMapData.getId(), errors);
 68:             } catch (Exception e) {
 69:                 throw new RuntimeException("Error while testing map: " + battleMapData, e);
 70:             }
 71:         }
 72: 
 73:         log.info("Map testing complete!");
 74:         this.saveResults(testOutputFile, results);
 75:         this.generateMapsJson(mapSource, results, testOptions);
 76: 
 77:         Bukkit.shutdown();
 78:     }
 79: 
 80:     private List<String> test(File mapsDirectory, BattleMapData mapData, int index) throws IOException {
 81:         BattleMapLoader parser;
 82:         if (mapData.getMetadata() != null) {
 83:             parser = new BattleMapMetadataLoader();
 84:         } else {
 85:             parser = new BattleMapSignLoader();
 86:         }
 87: 
 88:         World world;
 89:         try {
 90:             world = BattleWorldManager.create(
 91:                 mapsDirectory,
 92:                 index
 93:             );
 94:         } catch (FileNotFoundException e) {
 95:             return List.of("no_map_file");
 96:         }
 97: 
 98:         BattleGameConfig config;
 99:         try {
100:             config = parser.parse(mapData, world);
101:         } catch (Exception e) {
102:             return List.of("parser_error");
103:         }
104: 
105:         List<String> errors = this.evaluate(config);
106: 
107:         Bukkit.unloadWorld(world, false);
108: 
109:         return errors;
110:     }
111: 
112:     private List<String> evaluate(BattleGameConfig config) {
113:         List<String> errors = new ArrayList<>();
114: 
115:         for (BattleTeamConfig teamConfig : config.getTeamConfigs()) {
116:             if (teamConfig.getSpawn() == null) {
117:                 errors.add("missing_team_%s_spawn".formatted(teamConfig.getId()));
118:             }
119:             if (teamConfig.getFlag() == null) {
120:                 errors.add("missing_team_%s_flag".formatted(teamConfig.getId()));
121:             }
122:         }
123: 
124:         return errors;
125: 
126:     }
127: 
128:     private MapTestResults loadExistingResults(File outputFile) throws IOException {
129:         if (!outputFile.exists()) {
130:             outputFile.getParentFile().mkdir();
131:             return new MapTestResults();
132:         }
133: 
134:         return this.mapper.readValue(outputFile, MapTestResults.class);
135:     }
136: 
137:     private void saveResults(File outputFile, MapTestResults results) throws IOException {
138:         this.mapper.writeValue(outputFile, results);
139:         log.info("Saved testing results to {}", outputFile.getAbsoluteFile());
140:     }
141: 
142:     private void generateMapsJson(BattleMapSource repo, MapTestResults results, BattleOptionsInput.MapTesterOptions testerOptions) throws IOException {
143:         List<BattleMapData> maps = repo.getAll();
144:         for (BattleMapData map : maps) {
145:             List<String> errors = results.getErrors().get(map.getId());
146:             if (errors == null) {
147:                 continue;
148:             }
149: 
150:             map.setErrors(errors);
151:             map.setFunctional(errors.isEmpty());
152:         }
153: 
154:         File file = new File(testerOptions.getOutputDir(), "maps_" + testerOptions.getRunId() + ".json");
155:         this.mapper.writeValue(file, maps);
156: 
157:         log.info("Saved a new maps.json file to {}", file.getAbsolutePath());
158:     }
159: 
160:     @Data
161:     private static class MapTestResults {
162:         private Map<Integer, List<String>> errors = new HashMap<>();
163:     }
164: 
165: }
</file>

<file path="src/main/java/com/mcpvp/battle/scoreboard/BattleScoreboardManager.java">
  1: package com.mcpvp.battle.scoreboard;
  2: 
  3: import com.mcpvp.battle.Battle;
  4: import com.mcpvp.battle.BattlePlugin;
  5: import com.mcpvp.battle.game.BattleGamePlayerStats;
  6: import com.mcpvp.battle.game.BattleGameState;
  7: import com.mcpvp.battle.map.BattleMapData;
  8: import com.mcpvp.battle.role.Role;
  9: import com.mcpvp.battle.team.BattleTeam;
 10: import com.mcpvp.common.EasyLifecycle;
 11: import com.mcpvp.common.chat.C;
 12: import com.mcpvp.common.util.ScoreboardUtil;
 13: import lombok.Getter;
 14: import lombok.RequiredArgsConstructor;
 15: import org.bukkit.Bukkit;
 16: import org.bukkit.ChatColor;
 17: import org.bukkit.entity.Player;
 18: import org.bukkit.scoreboard.DisplaySlot;
 19: import org.bukkit.scoreboard.Objective;
 20: import org.bukkit.scoreboard.Scoreboard;
 21: import org.bukkit.scoreboard.Team;
 22: 
 23: import java.time.Duration;
 24: import java.util.ArrayList;
 25: import java.util.List;
 26: 
 27: @Getter
 28: @RequiredArgsConstructor
 29: public class BattleScoreboardManager extends EasyLifecycle {
 30: 
 31:     private final BattlePlugin plugin;
 32:     private final Battle battle;
 33: 
 34:     public void init() {
 35:         this.attach(new BattleScoreboardListener(this.plugin, this.battle, this));
 36:     }
 37: 
 38: 
 39: 
 40: 
 41:     public Scoreboard create() {
 42:         Scoreboard scoreboard = Bukkit.getScoreboardManager().getNewScoreboard();
 43:         Objective objective = scoreboard.registerNewObjective("score", "dummy");
 44:         objective.setDisplaySlot(DisplaySlot.SIDEBAR);
 45:         objective.setDisplayName(this.getTitle());
 46: 
 47:         for (BattleTeam bt : this.battle.getGame().getTeamManager().getTeams()) {
 48:             this.createTeam(scoreboard, bt);
 49:         }
 50: 
 51:         return scoreboard;
 52:     }
 53: 
 54: 
 55: 
 56: 
 57: 
 58: 
 59: 
 60:     public void setTeam(Player player, BattleTeam team) {
 61:         for (Scoreboard sb : this.getAllScoreboards()) {
 62:             this.getScoreboardTeam(sb, team).addEntry(player.getName());
 63:         }
 64:     }
 65: 
 66: 
 67: 
 68: 
 69: 
 70: 
 71: 
 72:     public void refresh(Player player) {
 73:         List<String> scores = this.getScores(player);
 74:         Objective objective = player.getScoreboard().getObjective(DisplaySlot.SIDEBAR);
 75:         ScoreboardUtil.resetChanged(player.getScoreboard(), scores);
 76:         ScoreboardUtil.addLargeScores(player.getScoreboard(), objective, scores);
 77:         objective.setDisplayName(this.getTitle());
 78:     }
 79: 
 80: 
 81: 
 82: 
 83: 
 84:     private List<Scoreboard> getAllScoreboards() {
 85:         return Bukkit.getOnlinePlayers().stream().map(Player::getScoreboard).toList();
 86:     }
 87: 
 88: 
 89: 
 90: 
 91: 
 92: 
 93: 
 94: 
 95:     private void createTeam(Scoreboard scoreboard, BattleTeam battleTeam) {
 96: 
 97:         Team team = scoreboard.registerNewTeam(this.getTeamName(battleTeam));
 98:         team.setAllowFriendlyFire(true);
 99:         team.setPrefix(battleTeam.getColor().toString());
100: 
101: 
102: 
103:         for (Player player : Bukkit.getOnlinePlayers()) {
104:             if (battleTeam.contains(player)) {
105:                 team.addEntry(player.getName());
106:             }
107:         }
108:     }
109: 
110: 
111: 
112: 
113: 
114: 
115: 
116: 
117:     private Team getScoreboardTeam(Scoreboard scoreboard, BattleTeam bt) {
118:         return scoreboard.getTeam(this.getTeamName(bt));
119:     }
120: 
121: 
122: 
123: 
124: 
125:     private String getTeamName(BattleTeam bt) {
126:         return "team_" + bt.getId();
127:     }
128: 
129: 
130: 
131: 
132: 
133: 
134: 
135:     private List<String> getScores(Player player) {
136:         List<String> scores = new ArrayList<>();
137: 
138:         BattleGameState state = this.battle.getGame().getState();
139:         if (state == null) {
140:             return scores;
141:         }
142: 
143:         switch (state) {
144:             case BEFORE:
145:                 scores.addAll(this.getMapDetails());
146:                 break;
147: 
148:             case DURING:
149: 
150:                 BattleTeam team = this.battle.getGame().getTeamManager().getTeam(player);
151:                 if (team != null) {
152:                     scores.addAll(this.getScoresForTeam(player, team));
153:                 }
154: 
155: 
156:                 this.battle.getGame().getTeamManager().getTeams().forEach(bt -> {
157:                     if (bt != team) {
158:                         scores.addAll(this.getScoresForTeam(player, bt));
159:                     }
160:                 });
161: 
162: 
163:                 scores.add("");
164: 
165:                 Role role = this.battle.getRoleManager().getRole(player);
166:                 String roleColor = C.GREEN; // default if no role
167: 
168:                 if (role == Role.ATTACK) {
169:                     roleColor = C.YELLOW;
170:                 } else if (role == Role.DEFENSE) {
171:                     roleColor = C.AQUA;
172:                 }
173: 
174:                 // Objective header value lines
175:                 scores.add(C.WHITE + C.B + " Objetivo");
176:                 String objective = this.battle.getRoleManager().computeObjectiveText(player);
177:                 if (objective != null) {
178:                     scores.add(roleColor + " " + objective);
179:                 } else {
180:                     scores.add(C.GRAY + " Sem funo selecionada");
181:                 }
182: 
183: 
184:                 break;
185: 
186:             case AFTER:
187: 
188:                 scores.addAll(this.getPlayerStats(player));
189:                 break;
190:         }
191: 
192:         return scores;
193:     }
194: 
195: 
196: 
197: 
198: 
199:     private List<String> getMapDetails() {
200:         BattleMapData map = this.battle.getGame().getMap();
201:         List<String> scores = new ArrayList<>();
202: 
203:         String[] authors = {"?"};
204:         if (map.getAuthor() != null)
205:             authors = map.getAuthor().split(", ");
206: 
207:         scores.addAll(ScoreboardUtil.wrap(" " + C.WHITE + C.B + "Players"));
208:         scores.add(ScoreboardUtil.autoSize("  " + C.GREEN + "Online", C.R + this.battle.getGame().getParticipants().size()));
209:         scores.add("  ");
210: 
211:         scores.addAll(ScoreboardUtil.wrap(" " + C.WHITE + C.B + "Map"));
212:         scores.add(ScoreboardUtil.autoSize("  " + C.GREEN + "Name", C.R + map.getName()));
213: 
214:         if (authors.length > 1) {
215:             scores.add("  " + C.GREEN + "By");
216:             for (String author : authors) {
217:                 scores.add("   " + author);
218:             }
219:         } else {
220:             scores.add(ScoreboardUtil.autoSize("  " + C.GREEN + "By", C.R + map.getAuthor()));
221:         }
222: 
223:         return scores;
224:     }
225: 
226: 
227: 
228: 
229: 
230: 
231: 
232: 
233:     private List<String> getScoresForTeam(Player player, BattleTeam team) {
234:         boolean sameTeam = this.battle.getGame().getTeamManager().getTeam(player) == team;
235:         List<String> scores = new ArrayList<>();
236: 
237:         if (sameTeam) {
238:             scores.add(" " + C.B + team.getName() + C.WHITE + " - Your Team");
239:         } else {
240:             scores.add(" " + C.B + team.getName());
241:         }
242: 
243:         scores.add(ScoreboardUtil.autoSize("  " + team.getColor() + "Captures" + C.R, team.getCaptures() + "/" + this.battle.getGame().getConfig().getCaps(), "  Caps"));
244: 
245:         List<String> location = this.getFlagLoc(team);
246: 
247:         scores.add("  " + team.getColor() + "Flag " + C.R + location.get(0));
248: 
249:         if (location.size() > 1) {
250:             scores.add(C.GRAY + "  * " + location.get(1));
251:         } else {
252:             scores.add(ChatColor.COLOR_CHAR + "" + team.getName().charAt(0) + ChatColor.RESET);
253:         }
254: 
255:         return scores;
256:     }
257: 
258:     /**
259:      * @param team The team to get the flag scores for.
260:      * @return A list of nicely formatted scores representing the current location
261:      * of the team's flag.
262:      */
263:     private List<String> getFlagLoc(BattleTeam team) {
264:         List<String> loc = new ArrayList<>();
265: 
266:         if (team.getFlag().isHome()) {
267:             loc.add("Home");
268:             return loc;
269:         }
270: 
271:         if (team.getFlag().getCarrier() != null) {
272:             BattleTeam heldTeam = this.battle.getGame().getTeamManager().getTeam(team.getFlag().getCarrier());
273:             loc.add("Taken");
274:             loc.add("Held by " + heldTeam.getColor().getChat() + team.getFlag().getCarrier().getName());
275:         }
276: 
277:         if (team.getFlag().isDropped()) {
278:             long timeLeft = team.getFlag().getRestoreExpiration().getRemaining().seconds();
279:             String timer = Math.max(0, timeLeft) + "s";
280: 
281:             loc.add("Dropped");
282:             loc.add("Resets in " + timer);
283:         }
284: 
285:         return loc;
286:     }
287: 
288: 
289: 
290: 
291:     private String getTitle() {
292:         String display = "[" + (this.battle.getMatch().getCurrentGameIndex() + 1) + "/" + this.battle.getMatch().getGames().size() + "] ";
293:         String timer = this.formatDuration(Duration.ofSeconds(this.battle.getMatch().getTimer().getSeconds()));
294: 
295:         if (this.battle.getMatch().getTimer().isPaused()) {
296:             timer += "*";
297:         }
298: 
299:         if (this.battle.getGame().getState() == null) {
300:             return "???";
301:         }
302: 
303:         switch (this.battle.getGame().getState()) {
304:             case BEFORE -> display += "Starts in " + timer;
305:             case DURING -> display += "Ends in " + timer;
306:             case AFTER -> {
307:                 if (this.battle.getMatch().getCurrentGameIndex() + 1 == this.battle.getMatch().getGames().size()) {
308:                     return "Match over! Restart in " + timer;
309:                 }
310:                 display += "Next map in " + timer;
311:             }
312:         }
313: 
314:         return display;
315:     }
316: 
317: 
318: 
319: 
320: 
321:     private List<String> getPlayerStats(Player player) {
322:         List<String> scores = new ArrayList<>();
323:         BattleGamePlayerStats stats = this.battle.getGame().getStats(player);
324: 
325:         scores.addAll(ScoreboardUtil.wrap(" " + C.RESET + C.B + "Your Stats"));
326:         scores.addAll(ScoreboardUtil.wrap("  " + C.GOLD + "Kills " + C.R + stats.getKills()));
327:         scores.addAll(ScoreboardUtil.wrap("  " + C.GOLD + "Deaths " + C.R + stats.getDeaths()));
328: 
329:         if (this.battle.getGame().getState() == BattleGameState.DURING) {
330:             scores.addAll(ScoreboardUtil.wrap("  " + C.GOLD + "Streak " + C.R + stats.getStreak()));
331:         } else if (this.battle.getGame().getState() == BattleGameState.AFTER) {
332:             scores.addAll(ScoreboardUtil.wrap("  " + C.GOLD + "Best Streak " + C.R + stats.getBestStreak()));
333:         }
334: 
335:         scores.addAll(ScoreboardUtil.wrap("  " + C.GOLD + "Recoveries " + C.R + stats.getRecovers()));
336:         scores.addAll(ScoreboardUtil.wrap("  " + C.GOLD + "Captures " + C.R + stats.getCaptures()));
337: 
338:         return scores;
339:     }
340: 
341:     private String formatDuration(Duration duration) {
342:         return String.format("%02d:%02d",
343:             duration.toMinutesPart(),
344:             duration.toSecondsPart()
345:         );
346:     }
347: 
348: }
</file>

<file path="src/main/java/com/mcpvp/battle/team/BattleTeam.java">
 1: package com.mcpvp.battle.team;
 2: 
 3: import com.mcpvp.battle.config.BattleTeamConfig;
 4: import com.mcpvp.battle.flag.BattleFlag;
 5: import com.mcpvp.battle.flag.FlagManager;
 6: import com.mcpvp.common.chat.C;
 7: import com.mcpvp.common.chat.Colors;
 8: import lombok.AllArgsConstructor;
 9: import lombok.Getter;
10: import lombok.Setter;
11: import lombok.ToString;
12: import org.bukkit.Location;
13: import org.bukkit.block.Block;
14: import org.bukkit.block.BlockFace;
15: import org.bukkit.entity.Player;
16: 
17: import java.util.HashSet;
18: import java.util.Set;
19: 
20: @Getter
21: @AllArgsConstructor
22: @ToString(of = {"id", "name"})
23: public class BattleTeam {
24: 
25:     private final int id;
26:     private final Set<Player> players = new HashSet<>();
27:     private final BattleTeamConfig config;
28:     private String name;
29:     private Colors color;
30:     @Setter
31:     private int captures;
32:     @Setter
33:     private BattleFlag flag;
34:     @Setter
35:     private FlagManager flagManager;
36: 
37:     public BattleTeam(int id, String name, Colors color, BattleTeamConfig config) {
38:         this.id = id;
39:         this.name = name;
40:         this.color = color;
41:         this.config = config;
42:     }
43: 
44:     void add(Player player) {
45:         this.players.add(player);
46:     }
47: 
48:     void remove(Player player) {
49:         this.players.remove(player);
50:     }
51: 
52:     public boolean contains(Player player) {
53:         return this.players.contains(player);
54:     }
55: 
56:     public void onCapture() {
57:         this.captures++;
58:     }
59: 
60:     public boolean isInSpawn(Player player) {
61:         return this.isInSpawn(player.getLocation());
62:     }
63: 
64:     public boolean isInSpawn(Location location) {
65:         Block underFeet = location.getBlock().getRelative(BlockFace.DOWN);
66:         Block spawnBlock = this.config.getSpawn().getBlock().getRelative(BlockFace.DOWN);
67:         return underFeet.getType() == spawnBlock.getType();
68:     }
69: 
70:     public String getColoredName() {
71:         return this.getColor() + this.getName() + C.R;
72:     }
73: 
74: }
</file>

<file path="src/main/java/com/mcpvp/common/ParticlePacket.java">
  1: package com.mcpvp.common;
  2: 
  3: import com.mcpvp.common.util.nms.PacketUtil;
  4: import lombok.Getter;
  5: import lombok.Setter;
  6: import net.minecraft.server.v1_8_R3.EnumParticle;
  7: import net.minecraft.server.v1_8_R3.PacketPlayOutWorldParticles;
  8: import org.apache.commons.lang3.Validate;
  9: import org.bukkit.Bukkit;
 10: import org.bukkit.Location;
 11: import org.bukkit.Material;
 12: import org.bukkit.World;
 13: import org.bukkit.entity.Player;
 14: 
 15: 
 16: 
 17: 
 18: 
 19: 
 20: 
 21: @Getter
 22: @SuppressWarnings("UnusedReturnValue")
 23: public class ParticlePacket {
 24: 
 25:     private EnumParticle particle;
 26:     @Setter
 27:     private int[] dataArray = null;
 28:     private float x;
 29:     private float y;
 30:     private float z;
 31:     private float offX = 0;
 32:     private float offY = 0;
 33:     private float offZ = 0;
 34:     private float data = 0;
 35:     private int count = 1;
 36:     private boolean showFar = true;
 37:     private World world;
 38: 
 39:     public ParticlePacket() {
 40: 
 41:     }
 42: 
 43:     public ParticlePacket(EnumParticle particle) {
 44:         this.particle = particle;
 45:     }
 46: 
 47:     public ParticlePacket(EnumParticle particle, Location location) {
 48:         this(particle);
 49:         this.at(location);
 50:     }
 51: 
 52:     public static ParticlePacket of(EnumParticle particle) {
 53:         return new ParticlePacket(particle);
 54:     }
 55: 
 56:     @SuppressWarnings("deprecation")
 57:     public static ParticlePacket blockDust(Material material) {
 58:         ParticlePacket packet = of(EnumParticle.BLOCK_CRACK);
 59:         packet.setDataArray(new int[]{material.getId(), 0});
 60:         return packet;
 61:     }
 62: 
 63: 
 64: 
 65: 
 66:     public static ParticlePacket colored(org.bukkit.Color color) {
 67:         return of(EnumParticle.REDSTONE).color(color);
 68:     }
 69: 
 70: 
 71: 
 72: 
 73:     public ParticlePacket type(EnumParticle particle) {
 74:         this.particle = particle;
 75:         return this;
 76:     }
 77: 
 78: 
 79: 
 80: 
 81:     public ParticlePacket at(Location location) {
 82:         this.x = (float) location.getX();
 83:         this.y = (float) location.getY();
 84:         this.z = (float) location.getZ();
 85:         this.world = location.getWorld();
 86:         return this;
 87:     }
 88: 
 89: 
 90: 
 91: 
 92:     public ParticlePacket in(World world) {
 93:         this.world = world;
 94:         return this;
 95:     }
 96: 
 97: 
 98: 
 99: 
100: 
101: 
102: 
103: 
104: 
105: 
106:     public ParticlePacket offset(float x, float y, float z) {
107:         this.setOffX(x);
108:         this.setOffY(y);
109:         this.setOffZ(z);
110:         return this;
111:     }
112: 
113: 
114: 
115: 
116: 
117: 
118: 
119:     public ParticlePacket setOffX(float offX) {
120:         this.offX = offX;
121:         return this;
122:     }
123: 
124: 
125: 
126: 
127: 
128: 
129: 
130:     public ParticlePacket setOffY(float offY) {
131:         this.offY = offY;
132:         return this;
133:     }
134: 
135: 
136: 
137: 
138: 
139: 
140: 
141:     public ParticlePacket setOffZ(float offZ) {
142:         this.offZ = offZ;
143:         return this;
144:     }
145: 
146: 
147: 
148: 
149: 
150: 
151: 
152: 
153:     public ParticlePacket spread(Number spread) {
154:         this.offset(spread.floatValue(), spread.floatValue(), spread.floatValue());
155:         return this;
156:     }
157: 
158: 
159: 
160: 
161: 
162:     public ParticlePacket setData(float data) {
163:         this.data = data;
164:         return this;
165:     }
166: 
167: 
168: 
169: 
170: 
171:     public ParticlePacket data(float data) {
172:         return this.setData(data);
173:     }
174: 
175:     public ParticlePacket setShowFar(boolean showFar) {
176:         this.showFar = showFar;
177:         return this;
178:     }
179: 
180: 
181: 
182: 
183:     public ParticlePacket showFar() {
184:         return this.setShowFar(true);
185:     }
186: 
187: 
188: 
189: 
190:     public ParticlePacket count(int count) {
191:         this.count = count;
192:         return this;
193:     }
194: 
195: 
196: 
197: 
198: 
199: 
200: 
201: 
202:     public ParticlePacket color(org.bukkit.Color color) {
203:         Validate.isTrue((this.particle == EnumParticle.REDSTONE || this.particle == EnumParticle.SPELL_MOB || this.particle == EnumParticle.NOTE), "Only redstone particles can be colored");
204:         this.count(0);
205:         this.setShowFar(false);
206:         this.setOffX(-1 + (color.getRed() * 1f / 255));
207:         this.setOffY(color.getGreen() * 1f / 255);
208:         this.setOffZ(color.getBlue() * 1f / 255);
209:         this.data(1);
210:         return this;
211:     }
212: 
213: 
214: 
215: 
216:     public ParticlePacket color(java.awt.Color color) {
217:         return this.color(org.bukkit.Color.fromRGB(color.getRGB()));
218:     }
219: 
220:     public String getParticleName() {
221:         return this.particle.name();
222:     }
223: 
224:     public void send() {
225:         Validate.notNull(this.particle);
226:         Validate.notNull(this.world);
227:         Bukkit.getOnlinePlayers().stream().filter(p -> p.getWorld().equals(this.world)).forEach(this::send);
228:     }
229: 
230:     public void send(Player player) {
231:         Validate.notNull(this.particle);
232:         Validate.notNull(this.world);
233:         PacketUtil.sendPacket(player, this.create());
234:     }
235: 
236:     public PacketPlayOutWorldParticles create() {
237:         return new PacketPlayOutWorldParticles(EnumParticle.valueOf(EnumParticle.class, this.getParticleName()),
238:             this.showFar,
239:             this.x, this.y, this.z,
240:             this.offX, this.offY, this.offZ,
241:             this.data,
242:             this.count,
243:             this.dataArray
244:         );
245:     }
246: 
247: }
</file>

<file path="src/main/java/com/mcpvp/battle/command/MapCommands.java">
 1: package com.mcpvp.battle.command;
 2: 
 3: import com.mcpvp.battle.Battle;
 4: import com.mcpvp.battle.map.BattleMapData;
 5: import com.mcpvp.common.chat.C;
 6: import com.mcpvp.common.command.EasyCommand;
 7: import com.mcpvp.common.command.EasyCommandGroup;
 8: import org.bukkit.command.CommandSender;
 9: 
10: import java.util.List;
11: 
12: public class MapCommands extends EasyCommandGroup {
13: 
14:     private final Battle battle;
15: 
16:     public MapCommands(Battle battle) {
17:         super(battle.getPlugin(), "map");
18:         this.battle = battle;
19: 
20:         this.addCommand(new InfoCommand(), true);
21:         this.addCommand(new OverrideCommand());
22:         this.addCommand(new NextCommand());
23:     }
24: 
25:     public class InfoCommand extends EasyCommand {
26: 
27:         public InfoCommand() {
28:             super("info");
29:         }
30: 
31:         @Override
32:         public boolean onCommand(CommandSender sender, String label, List<String> args) {
33:             BattleMapData map = MapCommands.this.battle.getGame().getMap();
34:             sender.sendMessage(C.cmdPass() + C.hl(map.getName()) + " by " + C.hl(map.getAuthor()) + " [" + map.getId() + "]");
35:             return true;
36:         }
37: 
38:     }
39: 
40:     public class OverrideCommand extends EasyCommand {
41: 
42:         public OverrideCommand() {
43:             super("override");
44:         }
45: 
46:         @Override
47:         public boolean onCommand(CommandSender sender, String label, List<String> args) {
48:             for (String id : args) {
49:                 if (!MapCommands.this.battle.getMapManager().isMap(Integer.parseInt(id))) {
50:                     sender.sendMessage(C.cmdFail() + C.hl(id) + " is not a valid map");
51:                     return false;
52:                 }
53:             }
54: 
55:             MapCommands.this.battle.getMapManager().setOverride(args.stream().map(Integer::parseInt).toList());
56:             sender.sendMessage(C.cmdPass() + "The requested maps will play on reboot");
57:             return true;
58:         }
59: 
60:     }
61: 
62:     public class NextCommand extends EasyCommand {
63: 
64:         public NextCommand() {
65:             super("next");
66:         }
67: 
68:         @Override
69:         public boolean onCommand(CommandSender sender, String label, List<String> args) {
70:             MapCommands.this.battle.getMatch().insertNextGame(Integer.parseInt(args.get(0)));
71:             sender.sendMessage(C.cmdPass() + "The requested map will play next");
72:             return true;
73:         }
74: 
75:     }
76: 
77: }
</file>

<file path="src/main/java/com/mcpvp/battle/command/SwitchCommand.java">
 1: package com.mcpvp.battle.command;
 2: 
 3: import com.mcpvp.battle.Battle;
 4: import com.mcpvp.battle.team.BattleTeam;
 5: import com.mcpvp.battle.team.BattleTeamManager;
 6: import com.mcpvp.common.chat.C;
 7: import com.mcpvp.common.command.EasyCommand;
 8: import org.bukkit.Bukkit;
 9: import org.bukkit.command.CommandSender;
10: import org.bukkit.entity.Player;
11: 
12: import java.util.List;
13: 
14: public class SwitchCommand extends EasyCommand {
15: 
16:     private final Battle battle;
17: 
18:     public SwitchCommand(Battle battle) {
19:         super("switch");
20:         this.battle = battle;
21:     }
22: 
23:     @Override
24:     public boolean onCommand(CommandSender sender, String label, List<String> args) {
25:         Player target = this.asPlayer(sender);
26: 
27: 
28:         if (!args.isEmpty()) {
29:             if (!sender.hasPermission("mcctf.switch.other")) {
30:                 return false;
31:             }
32: 
33:             Player player = Bukkit.getPlayer(args.get(0));
34:             if (player == null || !this.battle.getGame().isParticipant(player)) {
35:                 sender.sendMessage(C.cmdFail() + "This player is offline or not participating.");
36:                 return false;
37:             }
38: 
39:             target = player;
40:         }
41: 
42: 
43:         BattleTeamManager teamManager = this.battle.getGame().getTeamManager();
44:         BattleTeam current = teamManager.getTeam(target);
45:         BattleTeam next = teamManager.getNext(current);
46:         teamManager.setTeam(target, next);
47: 
48:         if (target != sender) {
49:             sender.sendMessage(C.cmdPass() + target.getPlayerListName() + " has been switched to " + next.getColoredName());
50:         }
51: 
52:         return true;
53:     }
54: 
55: }
</file>

<file path="src/main/java/com/mcpvp/battle/options/BattleOptionsInput.java">
  1: package com.mcpvp.battle.options;
  2: 
  3: import com.fasterxml.jackson.annotation.JsonSubTypes;
  4: import com.fasterxml.jackson.annotation.JsonTypeInfo;
  5: import com.mcpvp.battle.map.BattleMapCategory;
  6: import lombok.*;
  7: import lombok.extern.jackson.Jacksonized;
  8: 
  9: import java.util.ArrayList;
 10: import java.util.LinkedHashMap;
 11: import java.util.List;
 12: import java.util.Map;
 13: 
 14: 
 15: 
 16: 
 17: 
 18: @Getter
 19: @Setter
 20: @Builder
 21: @Jacksonized
 22: @AllArgsConstructor
 23: @NoArgsConstructor
 24: public class BattleOptionsInput {
 25: 
 26: 
 27: 
 28: 
 29:     @Builder.Default
 30:     private int version = 1;
 31:     @Builder.Default
 32:     private final String preferencesFile = "plugins/mcctf/preferences.json";
 33:     @Builder.Default
 34:     private final MatchOptions match = MatchOptions.builder().build();
 35:     @Builder.Default
 36:     private final GameOptions game = GameOptions.builder().build();
 37:     @Builder.Default
 38:     private final MapOptions maps = MapOptions.builder().build();
 39:     @Builder.Default
 40:     private final MapTesterOptions mapTester = MapTesterOptions.builder().build();
 41: 
 42:     @Data
 43:     @Builder
 44:     @Jacksonized
 45:     public static class MatchOptions {
 46: 
 47:         @Builder.Default
 48:         private final int games = 3;
 49: 
 50:     }
 51: 
 52:     @Data
 53:     @Builder
 54:     @Jacksonized
 55:     public static class GameOptions {
 56: 
 57:         @Builder.Default
 58:         private int secondsBeforeGame = 30;
 59:         @Builder.Default
 60:         private int secondsAfterGame = 15;
 61:         @Builder.Default
 62:         private FlagType flagType = FlagType.WOOL;
 63: 
 64:     }
 65: 
 66:     @Data
 67:     @Builder
 68:     @Jacksonized
 69:     public static class MapOptions {
 70: 
 71:         @Builder.Default
 72:         private final List<MapSourceOptions> sources = List.of(CentralMapSourceOptions.builder().build());
 73:         @Builder.Default
 74:         private final Map<BattleMapCategory, Boolean> categories = new LinkedHashMap<>() {
 75:             {
 76:                 for (int i = 0; i <= BattleMapCategory.WAVE20.ordinal(); i++) {
 77:                     this.put(BattleMapCategory.values()[i], true);
 78:                 }
 79:                 for (int i = BattleMapCategory.WAVE20.ordinal() + 1; i < BattleMapCategory.values().length; i++) {
 80:                     this.put(BattleMapCategory.values()[i], false);
 81:                 }
 82:                 this.put(BattleMapCategory.DEFAULT, false);
 83:                 this.put(BattleMapCategory.ORIGINAL, true);
 84:                 this.put(BattleMapCategory.VAULT, true);
 85:                 this.put(BattleMapCategory.VARIATION, true);
 86:             }
 87:         };
 88:         @Builder.Default
 89:         private final List<Integer> disable = new ArrayList<>();
 90: 
 91:     }
 92: 
 93:     @JsonSubTypes(value = {
 94:         @JsonSubTypes.Type(value = CentralMapSourceOptions.class, name = "central"),
 95:         @JsonSubTypes.Type(value = CustomMapSourceOptions.class, name = "custom")
 96:     })
 97:     @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = "type")
 98:     public sealed interface MapSourceOptions permits CentralMapSourceOptions, CustomMapSourceOptions {
 99: 
100:     }
101: 
102:     @Data
103:     @Builder
104:     @Jacksonized
105:     public static final class CentralMapSourceOptions implements MapSourceOptions {
106: 
107:         @Builder.Default
108:         private final String dir = "plugins/mcctf/maps";
109:         @Builder.Default
110:         private final String json = "plugins/mcctf/maps.json";
111: 
112:     }
113: 
114:     @Data
115:     @Builder
116:     @Jacksonized
117:     public static final class CustomMapSourceOptions implements MapSourceOptions {
118: 
119:         private final String dir;
120: 
121:     }
122: 
123:     @Data
124:     @Builder
125:     @Jacksonized
126:     public static class MapTesterOptions {
127: 
128:         @Builder.Default
129:         private final boolean enabled = false;
130:         @Builder.Default
131:         private final MapSourceOptions mapSource = CentralMapSourceOptions.builder().build();
132:         @Builder.Default
133:         private final String outputDir = "plugins/mcctf/maps_testing";
134:         @Builder.Default
135:         private final int runId = 1;
136: 
137:     }
138: 
139:     public enum FlagType {
140:         WOOL, BANNER
141:     }
142: 
143: }
</file>

<file path="src/main/java/com/mcpvp/common/command/EasyCommandGroup.java">
 1: package com.mcpvp.common.command;
 2: 
 3: import org.bukkit.command.CommandSender;
 4: import org.bukkit.command.PluginCommand;
 5: import org.bukkit.plugin.java.JavaPlugin;
 6: 
 7: import java.util.ArrayList;
 8: import java.util.List;
 9: import java.util.Optional;
10: 
11: public abstract class EasyCommandGroup extends EasyCommand {
12: 
13:     private final JavaPlugin plugin;
14:     private final List<EasyCommand> commands = new ArrayList<>();
15:     private EasyCommand defaultCommand;
16: 
17:     public EasyCommandGroup(JavaPlugin plugin, String name) {
18:         super(name);
19:         this.plugin = plugin;
20:     }
21: 
22:     protected void addCommand(EasyCommand command, boolean setDefault) {
23:         if (setDefault) {
24:             this.defaultCommand = command;
25:         }
26:         this.commands.add(command);
27:     }
28: 
29:     protected void addCommand(EasyCommand command) {
30:         this.addCommand(command, false);
31:     }
32: 
33:     @Override
34:     public boolean onCommand(CommandSender sender, String alias, List<String> args) {
35: 
36:         if (args.isEmpty()) {
37:             if (this.defaultCommand != null) {
38:                 return this.defaultCommand.onCommand(sender, alias, args);
39:             } else {
40:                 return false;
41:             }
42:         }
43: 
44: 
45:         Optional<EasyCommand> found = this.findCommand(args.get(0));
46: 
47:         return found.map(easyCommand -> {
48: 
49: 
50:             PluginCommand command = this.plugin.getCommand(alias + " " + args.get(0));
51:             command.testPermission(sender);
52: 
53:             return easyCommand.onCommand(sender, alias + " " + args.get(0), args.subList(1, args.size()));
54:         }).orElse(false);
55:     }
56: 
57:     @Override
58:     public List<String> getTabCompletions(CommandSender sender, String alias, List<String> args) {
59:         if (args.size() == 1) {
60:             return this.commands.stream().map(EasyCommand::getName).toList();
61:         }
62: 
63: 
64:         Optional<EasyCommand> found = this.findCommand(args.get(0));
65: 
66:         if (found.isPresent()) {
67:             return found.get().getTabCompletions(sender, alias, args.subList(1, args.size()));
68:         }
69: 
70:         return super.getTabCompletions(sender, alias, args);
71:     }
72: 
73:     protected Optional<EasyCommand> findCommand(String arg) {
74:         return this.commands.stream()
75:             .sorted((c1, c2) -> c2.getName().length() - c1.getName().length())
76:             .filter(c -> c.getName().equalsIgnoreCase(arg))
77:             .findFirst();
78:     }
79: 
80: }
</file>

<file path="src/main/java/com/mcpvp/common/kit/Kit.java">
 1: package com.mcpvp.common.kit;
 2: 
 3: import com.mcpvp.common.EasyLifecycle;
 4: import com.mcpvp.common.event.EasyListener;
 5: import com.mcpvp.common.item.ItemBuilder;
 6: import lombok.Getter;
 7: import lombok.NonNull;
 8: import org.bukkit.entity.Player;
 9: import org.bukkit.inventory.ItemFlag;
10: import org.bukkit.inventory.ItemStack;
11: import org.bukkit.plugin.Plugin;
12: import org.bukkit.projectiles.ProjectileSource;
13: 
14: import java.util.Collection;
15: import java.util.Map;
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: @Getter
24: public abstract class Kit extends EasyLifecycle implements KitInfo, EasyListener {
25: 
26:     protected final Plugin plugin;
27:     private final Player player;
28:     private final Map<Integer, KitItem> items;
29: 
30:     public Kit(Plugin plugin, Player player) {
31:         this.plugin = plugin;
32:         this.player = player;
33:         this.items = this.createItems();
34:         this.setup(player);
35:     }
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43:     protected void setup(@NonNull Player player) {
44:         this.attach((EasyListener) this);
45: 
46:         player.getInventory().clear();
47:         ItemStack[] armor = new ItemStack[4];
48:         ItemStack[] createdArmor = this.createArmor();
49:         for (int i = 0; i < createdArmor.length; i++) {
50:             if (createdArmor[i] != null) {
51: 
52:                 armor[i] = ItemBuilder.of(createdArmor[i]).flag(ItemFlag.HIDE_PLACED_ON).unbreakable().build();
53:             }
54:         }
55:         player.getInventory().setArmorContents(armor);
56: 
57:         this.items.entrySet().stream()
58:             .filter(e -> e.getValue() != null)
59:             .forEach(e -> {
60:                 this.attach(e.getValue());
61:                 player.getInventory().setItem(e.getKey(), e.getValue().getItem());
62:             });
63:     }
64: 
65:     @SuppressWarnings("BooleanMethodIsAlwaysInverted")
66:     protected boolean isPlayer(ProjectileSource source) {
67:         return source.equals(this.player);
68:     }
69: 
70:     public abstract String getName();
71: 
72: 
73: 
74: 
75:     public abstract ItemStack[] createArmor();
76: 
77: 
78: 
79: 
80: 
81:     public abstract Map<Integer, KitItem> createItems();
82: 
83: 
84: 
85: 
86: 
87:     public Collection<KitItem> getAllItems() {
88:         return this.items.values();
89:     }
90: 
91: }
</file>

<file path="build.gradle.kts">
 1: import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar
 2: import org.gradle.jvm.tasks.Jar
 3: 
 4: plugins {
 5:     `java-library`
 6:     id("com.github.johnrengelman.shadow").version("6.1.0")
 7: }
 8: 
 9: repositories {
10:     mavenCentral()
11:     
12:     maven {
13:         url = uri("https://nexus.velocitypowered.com/repository/maven-public/")
14:     }
15: }
16: 
17: dependencies {
18:     // These JARs are so old that they aren't on any repository, so include them locally
19:     compileOnly(files("libs/spigot-1.8.8.jar"))
20:     compileOnly(files("libs/craftbukkit-1.8.8.jar"))
21: 
22:     // JSON dependencies
23:     implementation("com.fasterxml.jackson.core:jackson-core:2.15.2")
24:     implementation("com.fasterxml.jackson.core:jackson-databind:2.15.2")
25:     implementation("com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.15.2")
26: 
27:     // Lombok
28:     compileOnly("org.projectlombok:lombok:1.18.26")
29:     annotationProcessor("org.projectlombok:lombok:1.18.26")
30: 
31:     // Logging
32:     compileOnly("org.apache.logging.log4j:log4j-api:2.22.0")
33: 
34:     // Plugin versioning
35:     implementation("com.github.zafarkhaja:java-semver:0.9.0")
36: }
37: 
38: val pluginVersion = "1.0"
39: 
40: group = "com.mcctf"
41: version = pluginVersion
42: description = "CTF"
43: java.sourceCompatibility = JavaVersion.VERSION_17
44: 
45: tasks.named<Jar>("jar") {
46:     manifest {
47:         archiveVersion.set(pluginVersion)
48:         archiveBaseName.set("brctf")
49:         attributes["CTF-Version"] = pluginVersion
50:     }
51: }
52: 
53: tasks.named<ShadowJar>("shadowJar") {
54:     archiveClassifier.set("") // remove the -all suffix
55:     archiveBaseName.set("brctf")
56:     archiveVersion.set(pluginVersion)
57:     destinationDirectory.set(file("D:/ctfserver/plugins"))
58: }
59: 
60: tasks.withType<JavaCompile> {
61:     options.encoding = "UTF-8"
62: }
</file>

<file path="src/main/java/com/mcpvp/battle/Battle.java">
  1: package com.mcpvp.battle;
  2: 
  3: import com.fasterxml.jackson.core.JsonParser;
  4: import com.fasterxml.jackson.databind.DeserializationFeature;
  5: import com.fasterxml.jackson.databind.ObjectMapper;
  6: import com.fasterxml.jackson.databind.SerializationFeature;
  7: import com.fasterxml.jackson.databind.util.StdDateFormat;
  8: import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
  9: import com.mcpvp.battle.game.BattleGame;
 10: import com.mcpvp.battle.game.BattleGameManager;
 11: import com.mcpvp.battle.kit.BattleInventoryManager;
 12: import com.mcpvp.battle.kit.BattleKitManager;
 13: import com.mcpvp.battle.map.BattleMapTester;
 14: import com.mcpvp.battle.map.BattleWorldManager;
 15: import com.mcpvp.battle.map.manager.BattleMapManager;
 16: import com.mcpvp.battle.map.manager.MergingMapManager;
 17: import com.mcpvp.battle.map.repo.BattleMapSource;
 18: import com.mcpvp.battle.match.BattleMatch;
 19: import com.mcpvp.battle.match.BattleMatchManager;
 20: import com.mcpvp.battle.options.BattleOptions;
 21: import com.mcpvp.battle.options.BattleOptionsLoader;
 22: import com.mcpvp.battle.role.RoleManager;
 23: import com.mcpvp.battle.role.RoleObjectiveListener;
 24: import com.mcpvp.battle.role.RolePreferenceGui;
 25: import com.mcpvp.common.preference.PreferenceManager;
 26: import com.mcpvp.common.structure.StructureManager;
 27: import com.mcpvp.common.visibility.VanillaVisibilityManager;
 28: import com.mcpvp.common.visibility.VisibilityManager;
 29: import lombok.Getter;
 30: import lombok.RequiredArgsConstructor;
 31: import lombok.extern.log4j.Log4j2;
 32: 
 33: import java.io.File;
 34: import java.io.IOException;
 35: import java.util.List;
 36: 
 37: @Getter
 38: @Log4j2
 39: @RequiredArgsConstructor
 40: public class Battle {
 41: 
 42:     private final BattlePlugin plugin;
 43:     private final ObjectMapper objectMapper = new ObjectMapper()
 44:         .enable(JsonParser.Feature.ALLOW_COMMENTS)
 45:         .enable(SerializationFeature.INDENT_OUTPUT)
 46:         .disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)
 47:         .registerModule(new JavaTimeModule())
 48:         .setDateFormat(new StdDateFormat().withColonInTimeZone(true))
 49:         .findAndRegisterModules();
 50: 
 51:     private BattleOptions options;
 52:     private BattleMapManager mapManager;
 53:     private BattleGameManager gameManager;
 54:     private BattleMatchManager matchManager;
 55:     private BattleKitManager kitManager;
 56:     private BattleMatch match;
 57:     private StructureManager structureManager;
 58:     private BattleInventoryManager inventoryManager;
 59:     private VisibilityManager visibilityManager;
 60:     private PreferenceManager preferenceManager;
 61:     private RoleManager roleManager;
 62:     private RolePreferenceGui rolePreferenceGui;
 63:     private RoleObjectiveListener roleObjectiveListener;
 64: 
 65:     public void load() throws IOException {
 66:         this.options = new BattleOptions(this.plugin, new BattleOptionsLoader(this.plugin, this.objectMapper));
 67:         this.mapManager = new MergingMapManager(this.plugin, this.options.getMaps(), this.loadMapRepos(this.options));
 68:         this.gameManager = new BattleGameManager(this);
 69:         this.matchManager = new BattleMatchManager(this.plugin, this, this.gameManager, this.mapManager);
 70:         this.kitManager = new BattleKitManager(this.plugin, this);
 71:         this.structureManager = new StructureManager();
 72:         this.inventoryManager = new BattleInventoryManager(this.plugin);
 73:         this.inventoryManager.loadAll();
 74:         this.visibilityManager = new VanillaVisibilityManager();
 75:         this.preferenceManager = new PreferenceManager(this.plugin, this.objectMapper, new File(this.options.getPreferencesFile()));
 76:         this.roleManager = new RoleManager(this.plugin, this, this.preferenceManager);
 77:         this.rolePreferenceGui = new RolePreferenceGui(this.plugin, this, this.roleManager);
 78:         this.roleObjectiveListener = new RoleObjectiveListener(this.plugin, this, this.roleManager);
 79: 
 80:         BattleWorldManager.cleanUpWorlds();
 81:     }
 82: 
 83:     private List<BattleMapSource> loadMapRepos(BattleOptions options) {
 84:         return options.getMaps().getSources().stream()
 85:             .map(source -> BattleMapSource.from(this.objectMapper, source))
 86:             .peek(BattleMapSource::init)
 87:             .toList();
 88:     }
 89: 
 90:     public void start() {
 91:         this.kitManager.getScoutDeathTagManager().register();
 92:         this.kitManager.getNecroRevivalTagManager().register();
 93:         this.visibilityManager.init();
 94:         this.roleManager.init();
 95:         this.rolePreferenceGui.init();
 96:         this.roleObjectiveListener.init();
 97: 
 98:         if (this.getOptions().getMapTester().isEnabled()) {
 99:             new BattleMapTester(this.objectMapper).run(
100:                 this.getOptions().getMapTester(),
101:                 BattleMapSource.from(this.objectMapper, this.getOptions().getMapTester().getMapSource()),
102:                 this.getMapManager()
103:             );
104:             return;
105:         }
106: 
107:         this.match = this.matchManager.create();
108:         this.match.start();
109: 
110:         log.info("Battle match starting now!");
111:     }
112: 
113:     public BattleGame getGame() {
114:         return this.getMatch().getCurrentGame();
115:     }
116: 
117: }
</file>

<file path="src/main/java/com/mcpvp/battle/command/CapturesCommand.java">
 1: package com.mcpvp.battle.command;
 2: 
 3: import com.mcpvp.battle.Battle;
 4: import com.mcpvp.battle.team.BattleTeam;
 5: import com.mcpvp.common.chat.C;
 6: import com.mcpvp.common.command.EasyCommand;
 7: import com.mcpvp.common.command.EasyCommandGroup;
 8: import org.bukkit.command.CommandSender;
 9: 
10: import java.util.List;
11: import java.util.Optional;
12: 
13: public class CapturesCommand extends EasyCommandGroup {
14: 
15:     private final Battle battle;
16: 
17:     public CapturesCommand(Battle battle) {
18:         super(battle.getPlugin(), "captures");
19:         this.battle = battle;
20:         this.addCommand(new SetCommand());
21:     }
22: 
23:     public List<String> matchTeam() {
24:         return this.battle.getGame().getTeamManager().getTeams().stream().map(BattleTeam::getName).toList();
25:     }
26: 
27:     public Optional<BattleTeam> findTeam(String arg) {
28:         return this.battle.getGame().getTeamManager().getTeams().stream()
29:             .filter(bt -> bt.getName().toLowerCase().contains(arg))
30:             .findAny();
31:     }
32: 
33:     public class SetCommand extends EasyCommand {
34: 
35:         public SetCommand() {
36:             super("set");
37:         }
38: 
39:         @Override
40:         public boolean onCommand(CommandSender sender, String label, List<String> args) {
41:             CapturesCommand.this.findTeam(args.get(0)).ifPresent(bt -> {
42:                 bt.setCaptures(Integer.parseInt(args.get(1)));
43:                 sender.sendMessage(C.cmdPass() + "Set captures for " + bt.getColoredName() + C.GRAY + " to " + C.hl(args.get(1)));
44:             });
45:             return true;
46:         }
47: 
48:         @Override
49:         public List<String> getTabCompletions(CommandSender sender, String alias, List<String> args) {
50:             return CapturesCommand.this.matchTeam();
51:         }
52: 
53:     }
54: 
55: }
</file>

<file path="src/main/java/com/mcpvp/battle/command/KitCommand.java">
 1: package com.mcpvp.battle.command;
 2: 
 3: import com.mcpvp.battle.kit.BattleKitManager;
 4: import com.mcpvp.common.chat.C;
 5: import com.mcpvp.common.command.EasyCommand;
 6: import com.mcpvp.common.kit.KitAttemptSelectEvent;
 7: import com.mcpvp.common.kit.KitDefinition;
 8: import org.bukkit.command.CommandSender;
 9: import org.bukkit.entity.Player;
10: 
11: import java.util.List;
12: import java.util.Random;
13: import java.util.function.Predicate;
14: 
15: public class KitCommand extends EasyCommand {
16: 
17:     private final BattleKitManager kitManager;
18: 
19:     public KitCommand(BattleKitManager kitManager) {
20: 
21:         super("kit");
22:         this.kitManager = kitManager;
23:     }
24: 
25:     @Override
26:     public boolean onCommand(CommandSender sender, String label, List<String> args) {
27:         Player player = this.asPlayer(sender);
28: 
29: 
30:         boolean isBaseLabel = label.equals("kit") || label.equals("class") || label.equals("classe");
31: 
32: 
33:         boolean isRandomLabel = label.equals("random") || label.equals("aleatorio");
34: 
35: 
36:         boolean argsContainRandom = args.contains("random") || args.contains("aleatorio");
37: 
38:         KitDefinition kit;
39:         if ((isBaseLabel && argsContainRandom) || isRandomLabel) {
40:             List<KitDefinition> eligible = this.kitManager.getKitDefinitions().stream()
41:                     .filter(Predicate.not(this.kitManager::isDisabled))
42:                     .toList();
43:             kit = eligible.get(new Random().nextInt(eligible.size()));
44:         } else if (isBaseLabel) {
45:             kit = this.kitManager.getKitDefinition(args.get(0));
46:         } else {
47:             kit = this.kitManager.getKitDefinition(label);
48:         }
49: 
50:         if (kit != null) {
51:             KitAttemptSelectEvent kitAttemptSelectEvent = this.kitManager.setSelected(
52:                     player, kit, false, !(args.contains("-f") && sender.isOp())
53:             );
54: 
55:             if (!kitAttemptSelectEvent.isCancelled()) {
56:                 player.sendMessage(C.cmdPass() + "Selected " + C.hl(kit.getName()));
57:                 return true;
58:             } else {
59:                 player.sendMessage(C.cmdFail() + kitAttemptSelectEvent.getDenial());
60:                 return false;
61:             }
62:         }
63: 
64:         return false;
65:     }
66: 
67: }
</file>

<file path="src/main/java/com/mcpvp/battle/command/TimerCommand.java">
 1: package com.mcpvp.battle.command;
 2: 
 3: import com.mcpvp.battle.Battle;
 4: import com.mcpvp.common.chat.C;
 5: import com.mcpvp.common.command.EasyCommand;
 6: import com.mcpvp.common.command.EasyCommandGroup;
 7: import org.bukkit.command.CommandSender;
 8: 
 9: import java.util.List;
10: 
11: public class TimerCommand extends EasyCommandGroup {
12: 
13:     private final Battle battle;
14: 
15:     public TimerCommand(Battle battle) {
16:         super(battle.getPlugin(), "timer");
17:         this.battle = battle;
18: 
19:         this.addCommand(new SetCommand());
20:         this.addCommand(new LockCommand());
21:         this.addCommand(new UnlockCommand());
22:         this.addCommand(new SkipCommand());
23:     }
24: 
25:     public class SetCommand extends EasyCommand {
26: 
27:         public SetCommand() {
28:             super("set");
29:         }
30: 
31:         @Override
32:         public boolean onCommand(CommandSender sender, String label, List<String> args) {
33:             if (args.isEmpty()) {
34:                 return false;
35:             }
36: 
37:             try {
38:                 int set = Integer.parseInt(args.get(0));
39:                 TimerCommand.this.battle.getMatch().getTimer().setSeconds(set);
40:                 sender.sendMessage(C.cmdPass() + "Timer set to " + C.hl(set) + " seconds");
41:                 return true;
42:             } catch (Exception e) {
43:                 return false;
44:             }
45:         }
46: 
47:     }
48: 
49:     public class LockCommand extends EasyCommand {
50: 
51:         public LockCommand() {
52:             super("lock");
53:         }
54: 
55:         @Override
56:         public boolean onCommand(CommandSender sender, String label, List<String> args) {
57:             TimerCommand.this.battle.getMatch().getTimer().setPaused(true);
58:             sender.sendMessage(C.cmdPass() + "Timer locked!");
59:             return true;
60:         }
61: 
62:     }
63: 
64:     public class UnlockCommand extends EasyCommand {
65: 
66:         public UnlockCommand() {
67:             super("unlock");
68:         }
69: 
70:         @Override
71:         public boolean onCommand(CommandSender sender, String label, List<String> args) {
72:             TimerCommand.this.battle.getMatch().getTimer().setPaused(false);
73:             sender.sendMessage(C.cmdPass() + "Timer unlocked!");
74:             return true;
75:         }
76: 
77:     }
78: 
79:     public class SkipCommand extends EasyCommand {
80: 
81:         public SkipCommand() {
82:             super("skip");
83:         }
84: 
85:         @Override
86:         public boolean onCommand(CommandSender sender, String label, List<String> args) {
87:             TimerCommand.this.battle.getMatch().advanceStateOrGame();
88:             sender.sendMessage(C.cmdPass() + "Skipping...");
89:             return true;
90:         }
91: 
92:     }
93: 
94: }
</file>

<file path="src/main/java/com/mcpvp/battle/match/BattleMatch.java">
  1: package com.mcpvp.battle.match;
  2: 
  3: import com.mcpvp.battle.Battle;
  4: import com.mcpvp.battle.BattlePlugin;
  5: import com.mcpvp.battle.hud.WaitUpManager;
  6: import com.mcpvp.battle.chat.BattleChatMessageHandler;
  7: import com.mcpvp.battle.game.BattleGame;
  8: import com.mcpvp.battle.game.BattleGameState;
  9: import com.mcpvp.battle.map.BattleMapData;
 10: import com.mcpvp.battle.team.BattleTeam;
 11: import com.mcpvp.common.chat.C;
 12: import lombok.Getter;
 13: import lombok.RequiredArgsConstructor;
 14: import org.bukkit.Bukkit;
 15: import org.bukkit.entity.Player;
 16: 
 17: import java.util.Collections;
 18: import java.util.List;
 19: import java.util.Map;
 20: import java.util.Set;
 21: 
 22: @RequiredArgsConstructor
 23: public class BattleMatch {
 24: 
 25:     private final BattlePlugin plugin;
 26:     private final Battle battle;
 27:     @Getter
 28:     private final List<BattleGame> games;
 29:     @Getter
 30:     private final BattleMatchTimer timer = new BattleMatchTimer();
 31:     @Getter
 32:     private int currentGameIndex = 0;
 33: 
 34:     public BattleGame getCurrentGame() {
 35:         return this.games.get(this.currentGameIndex);
 36:     }
 37: 
 38:     public void start() {
 39:         new BattleChatMessageHandler(this.plugin, this.battle).register();
 40:         new WaitUpManager(this.plugin, this.battle).register();
 41:         BattleMatchStructureRestrictions.register(this, this.battle.getStructureManager());
 42: 
 43:         Bukkit.getScheduler().runTaskTimer(this.plugin, this.getTimerTask(), 0, 20);
 44: 
 45:         this.getCurrentGame().setup(Collections.emptyMap());
 46:         this.battle.getRolePreferenceGui().openForAllParticipants();
 47:     }
 48: 
 49: 
 50: 
 51: 
 52:     private void advanceGame() {
 53: 
 54:         BattleGame current = this.getCurrentGame();
 55:         current.stop();
 56: 
 57: 
 58:         Map<BattleTeam, Set<Player>> playerMap = current.getTeamManager().getPlayerMap();
 59: 
 60: 
 61:         if (this.currentGameIndex + 1 == this.games.size()) {
 62:             Bukkit.broadcastMessage("All done!");
 63:             Bukkit.shutdown();
 64:         } else {
 65:             BattleGame next = this.games.get(++this.currentGameIndex);
 66:             next.setup(playerMap);
 67:             this.battle.getRolePreferenceGui().openForAllParticipants();
 68:         }
 69:     }
 70: 
 71: 
 72: 
 73: 
 74:     public void advanceStateOrGame() {
 75:         BattleGameState state = this.getCurrentGame().getState();
 76:         if (state == null) {
 77:             throw new IllegalStateException("Game state was null");
 78:         }
 79: 
 80:         if (state.getNext() != null) {
 81:             this.getCurrentGame().setState(state.getNext());
 82:         } else {
 83: 
 84:             this.advanceGame();
 85:         }
 86:     }
 87: 
 88:     public void insertNextGame(int map) {
 89:         BattleMapData battleMapData = this.battle.getMapManager().loadMap(map);
 90:         BattleGame game = this.battle.getGameManager().create(
 91:             battleMapData, this.battle.getMapManager().getWorldData(battleMapData), this.games.size() + 1
 92:         );
 93:         this.games.add(this.currentGameIndex + 1, game);
 94:     }
 95: 
 96: 
 97: 
 98: 
 99: 
100:     private Runnable getTimerTask() {
101:         return () -> {
102:             if (this.timer.isPaused()) {
103:                 return;
104:             }
105: 
106:             if (this.timer.getSeconds() == 0) {
107:                 this.advanceStateOrGame();
108:             } else if (!this.getCurrentGame().getParticipants().isEmpty()) {
109:                 this.timer.setSeconds(this.timer.getSeconds() - 1);
110:             }
111:         };
112:     }
113: 
114:     public String getMotd() {
115:         StringBuilder motd = new StringBuilder();
116: 
117:         if (this.getCurrentGame() == null) {
118:             motd.append("Starting up!");
119:             return motd.toString();
120:         }
121: 
122:         if (this.getCurrentGameIndex() == 0 && this.getCurrentGame().getState() == BattleGameState.BEFORE) {
123:             motd.append(C.cmd(C.YELLOW))
124:                 .append(C.WHITE)
125:                 .append("Starting soon! ")
126:                 .append("\n")
127:                 .append(C.info(C.YELLOW))
128:                 .append(C.WHITE)
129:                 .append("Map: ")
130:                 .append(this.getCurrentGame().getMap().getName());
131:         } else {
132:             motd.append(C.cmd(C.GREEN))
133:                 .append(C.WHITE)
134:                 .append("In progress! Game ")
135:                 .append(this.getCurrentGameIndex() + 1)
136:                 .append(" of ")
137:                 .append(this.getGames().size()).append(" ")
138:                 .append("\n")
139:                 .append(C.info(C.GREEN))
140:                 .append(C.WHITE)
141:                 .append("Map: ")
142:                 .append(this.getCurrentGame().getMap().getName());
143:         }
144: 
145:         return motd.toString();
146:     }
147: 
148: }
</file>

<file path="src/main/java/com/mcpvp/battle/command/KitManagerCommands.java">
  1: package com.mcpvp.battle.command;
  2: 
  3: import com.mcpvp.battle.Battle;
  4: import com.mcpvp.battle.kit.BattleKitManager;
  5: import com.mcpvp.battle.team.BattleTeam;
  6: import com.mcpvp.common.chat.C;
  7: import com.mcpvp.common.command.EasyCommand;
  8: import com.mcpvp.common.command.EasyCommandGroup;
  9: import com.mcpvp.common.kit.KitDefinition;
 10: import com.mcpvp.common.kit.KitInfo;
 11: import org.bukkit.command.CommandSender;
 12: import org.bukkit.entity.Player;
 13: 
 14: import java.util.*;
 15: import java.util.stream.Collectors;
 16: 
 17: public class KitManagerCommands extends EasyCommandGroup {
 18: 
 19:     private final Battle battle;
 20:     private final BattleKitManager kitManager;
 21: 
 22:     public KitManagerCommands(Battle battle, BattleKitManager kitManager) {
 23:         super(battle.getPlugin(), "kits");
 24:         this.battle = battle;
 25:         this.kitManager = kitManager;
 26:         this.addCommand(new SummaryCommand(), true);
 27:         this.addCommand(new DisableCommand());
 28:         this.addCommand(new EnableCommand());
 29:         this.addCommand(new LimitCommands());
 30:     }
 31: 
 32:     private List<String> completeKits() {
 33:         List<String> kits = new ArrayList<>();
 34:         kits.add("all");
 35:         kits.addAll(this.kitManager.getKitDefinitions().stream().map(KitInfo::getName).toList());
 36:         return kits;
 37:     }
 38: 
 39:     private List<KitDefinition> findKit(String arg) {
 40:         if (arg.equalsIgnoreCase("all")) {
 41:             return this.kitManager.getKitDefinitions();
 42:         }
 43:         return List.of(this.kitManager.getKitDefinition(arg));
 44:     }
 45: 
 46:     public class SummaryCommand extends EasyCommand {
 47: 
 48:         protected SummaryCommand() {
 49:             super("summary");
 50:         }
 51: 
 52:         @Override
 53:         public boolean onCommand(CommandSender sender, String label, List<String> args) {
 54:             List<KitDefinition> disabled = KitManagerCommands.this.kitManager.getKitDefinitions().stream().filter(KitManagerCommands.this.kitManager::isDisabled).toList();
 55:             List<KitDefinition> limited = KitManagerCommands.this.kitManager.getKitDefinitions().stream()
 56:                 .filter(kit -> KitManagerCommands.this.kitManager.getLimit(kit).isPresent())
 57:                 .sorted(Comparator.comparingInt(kit -> -KitManagerCommands.this.kitManager.getLimit(kit).orElse(0)))
 58:                 .toList();
 59: 
 60:             sender.sendMessage(C.BOLD + "Class Management Summary");
 61: 
 62:             String disabledText = disabled.stream().map(KitDefinition::getName).collect(Collectors.joining(C.GRAY + ", " + C.R));
 63:             if (disabledText.isBlank()) {
 64:                 disabledText = C.R + "none";
 65:             }
 66:             sender.sendMessage(C.info(C.RED) + "Disabled: " + disabledText);
 67: 
 68: 
 69:             StringBuilder sb = new StringBuilder(C.info(C.PURPLE) + "Limited: ");
 70:             if (!limited.isEmpty()) {
 71:                 sb.append(limited.stream().map(kit -> {
 72:                     StringBuilder inner = new StringBuilder("\n    ");
 73:                     inner.append(kit.getName());
 74:                     inner.append(": ");
 75:                     inner.append(C.R);
 76:                     inner.append(KitManagerCommands.this.kitManager.getLimit(kit).map(Object::toString).orElse("none"));
 77: 
 78:                     Map<BattleTeam, List<Player>> playing = new HashMap<>();
 79:                     KitManagerCommands.this.battle.getGame().getTeamManager().getTeams().forEach(team -> {
 80:                         List<Player> onTeam = team.getPlayers().stream()
 81:                             .filter(player -> KitManagerCommands.this.battle.getKitManager().isSelected(player, kit))
 82:                             .toList();
 83: 
 84:                         if (!onTeam.isEmpty()) {
 85:                             playing.put(team, onTeam);
 86:                         }
 87:                     });
 88: 
 89:                     if (!playing.isEmpty()) {
 90:                         inner.append(C.GRAY);
 91:                         inner.append(" [");
 92:                         playing.forEach((battleTeam, players) -> {
 93:                             inner.append(players.stream().map(player -> {
 94:                                 return battleTeam.getColor().getChat() + player.getName();
 95:                             }).collect(Collectors.joining(C.GRAY + ", ")));
 96: 
 97:                             inner.append(" ");
 98:                             inner.append(C.GRAY);
 99:                             inner.append("(");
100:                             inner.append(C.hl(players.size()));
101:                             inner.append(")");
102:                         });
103:                         inner.append(C.GRAY);
104:                         inner.append("]");
105:                     }
106: 
107:                     return inner.toString();
108:                 }).collect(Collectors.joining(C.GRAY + "\n")));
109:             } else {
110:                 sb.append(C.R);
111:                 sb.append("none");
112:             }
113: 
114:             sender.sendMessage(sb.toString());
115: 
116:             return false;
117:         }
118: 
119:     }
120: 
121:     public class DisableCommand extends EasyCommand {
122: 
123:         protected DisableCommand() {
124:             super("disable");
125:         }
126: 
127:         @Override
128:         public boolean onCommand(CommandSender sender, String label, List<String> args) {
129:             List<KitDefinition> kits = KitManagerCommands.this.findKit(args.get(0));
130:             if (kits.isEmpty()) {
131:                 return false;
132:             }
133: 
134:             kits.forEach(KitManagerCommands.this.kitManager::setDisabled);
135:             sender.sendMessage(C.cmdPass() + "Disabled " + kits.stream().map(KitDefinition::getName).collect(Collectors.joining(", ")));
136: 
137:             return true;
138:         }
139: 
140:         @Override
141:         public List<String> getTabCompletions(CommandSender sender, String alias, List<String> args) {
142:             return KitManagerCommands.this.completeKits();
143:         }
144: 
145:     }
146: 
147:     public class EnableCommand extends EasyCommand {
148: 
149:         protected EnableCommand() {
150:             super("enable");
151:         }
152: 
153:         @Override
154:         public boolean onCommand(CommandSender sender, String label, List<String> args) {
155:             List<KitDefinition> kits = KitManagerCommands.this.findKit(args.get(0));
156:             if (kits.isEmpty()) {
157:                 return false;
158:             }
159: 
160:             kits.forEach(KitManagerCommands.this.kitManager::setEnabled);
161:             sender.sendMessage(C.cmdPass() + "Enabled " + kits.stream().map(KitDefinition::getName).collect(Collectors.joining(", ")));
162: 
163:             return true;
164:         }
165: 
166:         @Override
167:         public List<String> getTabCompletions(CommandSender sender, String alias, List<String> args) {
168:             return KitManagerCommands.this.completeKits();
169:         }
170: 
171:     }
172: 
173:     public class LimitCommands extends EasyCommandGroup {
174: 
175:         public LimitCommands() {
176:             super(KitManagerCommands.this.battle.getPlugin(), "limit");
177:             this.addCommand(new SetCommand());
178:             this.addCommand(new RemoveCommand());
179:         }
180: 
181:         public class SetCommand extends EasyCommand {
182: 
183:             protected SetCommand() {
184:                 super("set");
185:             }
186: 
187:             @Override
188:             public boolean onCommand(CommandSender sender, String label, List<String> args) {
189:                 if (args.size() < 2) {
190:                     return false;
191:                 }
192: 
193:                 List<KitDefinition> kits = KitManagerCommands.this.findKit(args.get(0));
194:                 if (kits.isEmpty()) {
195:                     return false;
196:                 }
197: 
198:                 int limit = Integer.parseInt(args.get(1));
199:                 kits.forEach(kit -> {
200:                     KitManagerCommands.this.kitManager.setLimit(kit, limit);
201:                 });
202:                 sender.sendMessage(C.cmdPass() + "Limited " + C.R + kits.stream()
203:                     .map(KitDefinition::getName)
204:                     .collect(Collectors.joining(C.GRAY + ", " + C.R)) + C.GRAY + " to " + C.hl(limit)
205:                 );
206: 
207:                 return true;
208:             }
209: 
210:             @Override
211:             public List<String> getTabCompletions(CommandSender sender, String alias, List<String> args) {
212:                 return KitManagerCommands.this.completeKits();
213:             }
214: 
215:         }
216: 
217:         public class RemoveCommand extends EasyCommand {
218: 
219:             protected RemoveCommand() {
220:                 super("remove");
221:             }
222: 
223:             @Override
224:             public boolean onCommand(CommandSender sender, String label, List<String> args) {
225:                 List<KitDefinition> kits = KitManagerCommands.this.findKit(args.get(0));
226:                 if (kits.isEmpty()) {
227:                     return false;
228:                 }
229: 
230:                 kits.forEach(KitManagerCommands.this.kitManager::removeLimit);
231:                 sender.sendMessage(C.cmdPass() + "Removed limit on " + C.R + kits.stream()
232:                     .map(KitDefinition::getName)
233:                     .collect(Collectors.joining(C.GRAY + ", " + C.R))
234:                 );
235: 
236:                 return true;
237:             }
238: 
239:             @Override
240:             public List<String> getTabCompletions(CommandSender sender, String alias, List<String> args) {
241:                 return KitManagerCommands.this.completeKits();
242:             }
243: 
244:         }
245: 
246:     }
247: 
248: }
</file>

<file path="src/main/java/com/mcpvp/common/command/EasyCommand.java">
 1: package com.mcpvp.common.command;
 2: 
 3: import lombok.Getter;
 4: import org.bukkit.Bukkit;
 5: import org.bukkit.command.*;
 6: import org.bukkit.entity.Player;
 7: import org.bukkit.plugin.java.JavaPlugin;
 8: 
 9: import java.util.Arrays;
10: import java.util.List;
11: 
12: @Getter
13: public abstract class EasyCommand implements CommandExecutor, TabCompleter {
14: 
15:     private final String name;
16: 
17:     protected EasyCommand(String name) {
18:         this.name = name;
19:     }
20: 
21:     @Override
22:     public boolean onCommand(CommandSender var1, Command var2, String var3, String[] var4) {
23:         return this.onCommand(var1, var3, Arrays.asList(var4));
24:     }
25: 
26:     public abstract boolean onCommand(CommandSender sender, String label, List<String> args);
27: 
28:     @Override
29:     public List<String> onTabComplete(CommandSender var1, Command var2, String var3, String[] var4) {
30:         return CommandUtil.partialMatches(this.getTabCompletions(var1, var3, Arrays.asList(var4)), var4[var4.length - 1]);
31:     }
32: 
33:     public List<String> getTabCompletions(CommandSender sender, String alias, List<String> args) {
34:         return Bukkit.getOnlinePlayers().stream().map(Player::getName).toList();
35:     }
36: 
37:     public void register(JavaPlugin plugin) {
38:         PluginCommand command = plugin.getCommand(this.name);
39:         if (command == null) {
40:             throw new IllegalStateException("No command registered for " + this.name);
41:         }
42: 
43:         command.setExecutor(this);
44:         command.setTabCompleter(this);
45:     }
46: 
47:     public void register(JavaPlugin plugin, String name) {
48:         PluginCommand command = plugin.getCommand(name);
49:         if (command == null) {
50:             throw new IllegalStateException("No command registered for " + name);
51:         }
52: 
53:         command.setExecutor(this);
54:         command.setTabCompleter(this);
55:     }
56: 
57:     protected Player asPlayer(CommandSender sender) {
58:         if (!(sender instanceof Player)) {
59:             throw new IllegalStateException("Only players can execute this command.");
60:         }
61: 
62:         return ((Player) sender);
63:     }
64: 
65: }
</file>

<file path="src/main/java/com/mcpvp/battle/command/FlagCommands.java">
  1: package com.mcpvp.battle.command;
  2: 
  3: import com.google.common.collect.Sets;
  4: import com.mcpvp.battle.Battle;
  5: import com.mcpvp.battle.BattlePreferences;
  6: import com.mcpvp.battle.flag.display.FlagDisplayChannel;
  7: import com.mcpvp.battle.options.BattleOptionsInput;
  8: import com.mcpvp.battle.team.BattleTeam;
  9: import com.mcpvp.common.chat.C;
 10: import com.mcpvp.common.command.EasyCommand;
 11: import com.mcpvp.common.command.EasyCommandGroup;
 12: import org.bukkit.command.CommandSender;
 13: import org.bukkit.entity.Player;
 14: 
 15: import java.io.IOException;
 16: import java.util.Arrays;
 17: import java.util.List;
 18: import java.util.Optional;
 19: import java.util.Set;
 20: 
 21: public class FlagCommands extends EasyCommandGroup {
 22: 
 23:     private final Battle battle;
 24: 
 25:     public FlagCommands(Battle battle) {
 26:         super(battle.getPlugin(), "flag");
 27:         this.battle = battle;
 28:         this.addCommand(new JumpCommand());
 29:         this.addCommand(new LockCommand());
 30:         this.addCommand(new UnlockCommand());
 31:         this.addCommand(new ResetCommand());
 32:         this.addCommand(new DisplayCommand());
 33:         this.addCommand(new TypeCommand());
 34:     }
 35: 
 36:     public List<String> matchTeam() {
 37:         return this.battle.getGame().getTeamManager().getTeams().stream().map(BattleTeam::getName).toList();
 38:     }
 39: 
 40:     public Optional<BattleTeam> findTeam(String arg) {
 41:         return this.battle.getGame().getTeamManager().getTeams().stream()
 42:             .filter(bt -> bt.getName().toLowerCase().contains(arg))
 43:             .findAny();
 44:     }
 45: 
 46:     public class JumpCommand extends EasyCommand {
 47: 
 48:         public JumpCommand() {
 49:             super("jump");
 50:         }
 51: 
 52:         @Override
 53:         public boolean onCommand(CommandSender sender, String label, List<String> args) {
 54:             FlagCommands.this.findTeam(args.get(0)).ifPresent(bt -> {
 55:                 ((Player) sender).teleport(bt.getFlag().getLocation());
 56:             });
 57:             return true;
 58:         }
 59: 
 60:         @Override
 61:         public List<String> getTabCompletions(CommandSender sender, String alias, List<String> arg) {
 62:             return FlagCommands.this.matchTeam();
 63:         }
 64: 
 65:     }
 66: 
 67:     public class LockCommand extends EasyCommand {
 68: 
 69:         public LockCommand() {
 70:             super("lock");
 71:         }
 72: 
 73:         @Override
 74:         public boolean onCommand(CommandSender sender, String label, List<String> args) {
 75:             FlagCommands.this.findTeam(args.get(0)).ifPresent(bt -> {
 76:                 bt.getFlag().setLocked(true);
 77:             });
 78:             return true;
 79:         }
 80: 
 81:         @Override
 82:         public List<String> getTabCompletions(CommandSender sender, String alias, List<String> arg) {
 83:             return FlagCommands.this.matchTeam();
 84:         }
 85: 
 86:     }
 87: 
 88:     public class UnlockCommand extends EasyCommand {
 89: 
 90:         public UnlockCommand() {
 91:             super("unlock");
 92:         }
 93: 
 94:         @Override
 95:         public boolean onCommand(CommandSender sender, String label, List<String> args) {
 96:             FlagCommands.this.findTeam(args.get(0)).ifPresent(bt -> {
 97:                 bt.getFlag().setLocked(false);
 98:             });
 99:             return true;
100:         }
101: 
102:         @Override
103:         public List<String> getTabCompletions(CommandSender sender, String alias, List<String> arg) {
104:             return FlagCommands.this.matchTeam();
105:         }
106: 
107:     }
108: 
109:     public class ResetCommand extends EasyCommand {
110: 
111:         public ResetCommand() {
112:             super("reset");
113:         }
114: 
115:         @Override
116:         public boolean onCommand(CommandSender sender, String label, List<String> args) {
117:             FlagCommands.this.findTeam(args.get(0)).ifPresent(bt -> {
118:                 bt.getFlag().reset();
119:             });
120:             return true;
121:         }
122: 
123:         @Override
124:         public List<String> getTabCompletions(CommandSender sender, String alias, List<String> arg) {
125:             return FlagCommands.this.matchTeam();
126:         }
127: 
128:     }
129: 
130:     public class DisplayCommand extends EasyCommand {
131: 
132:         public DisplayCommand() {
133:             super("display");
134:         }
135: 
136:         @Override
137:         public boolean onCommand(CommandSender sender, String label, List<String> args) {
138:             if (args.size() != 2) {
139:                 return false;
140:             }
141: 
142:             FlagDisplayChannel channel = FlagDisplayChannel.valueOf(args.get(0).toUpperCase());
143:             boolean active = args.get(1).equalsIgnoreCase("on");
144: 
145:             Set<FlagDisplayChannel> current = FlagCommands.this.battle.getPreferenceManager().find(
146:                 this.asPlayer(sender), BattlePreferences.FLAG_DISPLAY
147:             ).orElse(Sets.newHashSet(FlagDisplayChannel.CHAT));
148: 
149:             if (active) {
150:                 current.add(channel);
151:             } else {
152:                 current.remove(channel);
153:             }
154: 
155:             FlagCommands.this.battle.getPreferenceManager().store(
156:                 this.asPlayer(sender), BattlePreferences.FLAG_DISPLAY, current
157:             );
158: 
159:             if (active) {
160:                 sender.sendMessage(C.cmdPass() + "Alerts " + C.hl("enabled") + " on the " + C.hl(channel.name().toLowerCase()) + " channel");
161:             } else {
162:                 sender.sendMessage(C.cmdPass() + "Alerts " + C.hl("disabled") + " on the " + C.hl(channel.name().toLowerCase()) + " channel");
163:             }
164: 
165:             return true;
166:         }
167: 
168:         @Override
169:         public List<String> getTabCompletions(CommandSender sender, String alias, List<String> args) {
170:             if (args.size() == 1) {
171:                 return Arrays.stream(FlagDisplayChannel.values()).map(Enum::name).toList();
172:             } else if (args.size() == 2) {
173:                 return List.of("on", "off");
174:             }
175: 
176:             return super.getTabCompletions(sender, alias, args);
177:         }
178: 
179:     }
180: 
181:     public class TypeCommand extends EasyCommand {
182: 
183:         public TypeCommand() {
184:             super("type");
185:         }
186: 
187:         @Override
188:         public boolean onCommand(CommandSender sender, String label, List<String> args) {
189:             if (args.isEmpty()) {
190:                 return false;
191:             }
192: 
193:             BattleOptionsInput.FlagType flagType = BattleOptionsInput.FlagType.valueOf(args.get(0).toUpperCase());
194:             FlagCommands.this.battle.getGame().setupFlags(flagType);
195:             sender.sendMessage(C.cmdPass() + "Changed to flag type " + C.hl(flagType.name().toLowerCase()));
196: 
197:             try {
198:                 FlagCommands.this.battle.getOptions().edit(opts -> {
199:                     opts.getGame().setFlagType(flagType);
200:                 });
201:             } catch (IOException e) {
202:                 sender.sendMessage(C.cmdFail() + "Failed to save changes");
203:                 return false;
204:             }
205: 
206:             return true;
207:         }
208: 
209:         @Override
210:         public List<String> getTabCompletions(CommandSender sender, String alias, List<String> args) {
211:             return Arrays.stream(BattleOptionsInput.FlagType.values()).map(Enum::name).toList();
212:         }
213:     }
214: 
215: }
</file>

<file path="src/main/java/com/mcpvp/battle/BattlePlugin.java">
 1: package com.mcpvp.battle;
 2: 
 3: import com.mcpvp.battle.command.*;
 4: import com.mcpvp.common.event.TickEvent;
 5: import lombok.Getter;
 6: import lombok.SneakyThrows;
 7: import lombok.extern.log4j.Log4j2;
 8: import org.bukkit.Bukkit;
 9: import org.bukkit.plugin.java.JavaPlugin;
10: 
11: import java.util.concurrent.atomic.AtomicInteger;
12: 
13: @Log4j2
14: public class BattlePlugin extends JavaPlugin {
15: 
16:     @Getter
17:     private Battle battle;
18: 
19:     @SneakyThrows
20:     @Override
21:     public void onLoad() {
22:         super.onLoad();
23: 
24:         this.battle = new Battle(this);
25:         this.battle.load();
26:     }
27: 
28:     @Override
29:     public void onEnable() {
30:         super.onEnable();
31: 
32:         final AtomicInteger tick = new AtomicInteger();
33:         Bukkit.getScheduler().runTaskTimer(this, () -> {
34:             try {
35:                 new TickEvent(tick.getAndIncrement()).call();
36:             } catch (Exception e) {
37:                 log.error("TickEvent error", e);
38:             }
39:         }, 1, 1);
40: 
41:         this.registerCommands();
42:         this.battle.start();
43:     }
44: 
45:     private void registerCommands() {
46:         new CapturesCommand(this.battle).register(this);
47:         new FlagCommands(this.battle).register(this);
48:         new KitCommand(this.battle.getKitManager()).register(this);
49:         new KitManagerCommands(this.battle, this.battle.getKitManager()).register(this);
50:         new MapCommands(this.battle).register(this);
51:         new RespawnCommand(this.battle).register(this);
52:         new SwitchCommand(this.battle).register(this);
53:         new TimerCommand(this.battle).register(this);
54:         new YellCommand().register(this);
55: 
56:         QuickCommands.registerAll(this.battle);
57:     }
58: 
59: }
</file>

<file path="src/main/resources/plugin.yml">
  1: name: mcctf
  2: version: 3.5.0
  3: description: The classic MCPVP plugin reborn
  4: author: NomNuggetNom
  5: main: com.mcpvp.battle.BattlePlugin
  6: depend: []
  7: permissions:
  8:   mcctf.flag.jump:
  9:     description: Allow access to /flag jump
 10:     default: op
 11:   mcctf.flag.lock:
 12:     description: Allow access to /flag lock
 13:     default: op
 14:   mcctf.flag.unlock:
 15:     description: Allow access to /flag unlock
 16:     default: op
 17:   mcctf.flag.reset:
 18:     description: Allow access to /flag reset
 19:     default: op
 20:   mcctf.flag.type:
 21:     description: Allow access to /flag type
 22:     default: op
 23:   mcctf.flag.display:
 24:     description: Allow access to /flag display
 25:     default: true
 26: 
 27:   mcctf.kit:
 28:     description: Allow access to /kit <class>
 29:     default: true
 30: 
 31:   mcctf.kits.disable:
 32:     description: Allow access to /kits disable
 33:     default: op
 34:   mcctf.kits.enable:
 35:     description: Allow access to /kits enable
 36:     default: op
 37:   mcctf.kits.limit:
 38:     description: Allow access to /kits limit <set|remove>
 39:     default: op
 40:   mcctf.kits.summary:
 41:     description: Allow access to /kits summary
 42:     default: true
 43: 
 44:   mcctf.respawn:
 45:     description: Allows access to /respawn
 46:     default: true
 47: 
 48:   mcctf.map.override:
 49:     description: Allow access to /map override
 50:     default: op
 51:   mcctf.map.next:
 52:     description: Allow access to /map next
 53:     default: op
 54:   mcctf.map.info:
 55:     description: Allow access to /map info
 56:     default: true
 57: 
 58:   mcctf.timer.set:
 59:     description: Allow access to /timer set
 60:     default: op
 61:   mcctf.timer.lock:
 62:     description: Allow access to /timer lock
 63:     default: op
 64:   mcctf.timer.unlock:
 65:     description: Allow access to /timer unlock
 66:     default: op
 67:   mcctf.timer.skip:
 68:     description: Allow access to /timer skip
 69:     default: op
 70: 
 71:   mcctf.yell:
 72:     description: Allow access to /yell
 73:     default: true
 74: 
 75:   mcctf.switch:
 76:     description: Allow access to SELF /switch
 77:     default: true
 78:   mcctf.switch.other:
 79:     description: Allow switching the team of other players
 80:     default: op
 81: commands:
 82:   captures:
 83:     description: Capture management commands
 84:   captures set:
 85:     description: Set the number of captures for a team
 86:     usage: /<command> <team> <number>
 87:     permission: mcctf.captures.set
 88:   flag:
 89:     description: Flag commands
 90:   flag jump:
 91:     description: Jump to a flag
 92:     usage: /<command> <team>
 93:     permission: mcctf.flag.jump
 94:   flag lock:
 95:     description: Lock a flag to prevent it from being stolen
 96:     usage: /<command> <team>
 97:     permission: mcctf.flag.lock
 98:   flag unlock:
 99:     description: Unlock a flag to allow it to be stolen
100:     usage: /<command> <team>
101:     permission: mcctf.flag.unlock
102:   flag reset:
103:     description: Reset a flag to its normal state
104:     usage: /<command> <team>
105:     permission: mcctf.flag.reset
106:   flag display:
107:     description: Control which channels flag alerts are visible on
108:     usage: /<command> <chat | subtitle | actionbar> <on | off>
109:     permission: mcctf.flag.display
110:   flag type:
111:     description: Change the flag type
112:     usage: /<command> <wool | banner>
113:     permission: mcctf.flag.type
114:   kit:
115:     description: Select a class
116:     usage: /<command> <class | random>
117:     aliases: [class, archer, assassin, chemist, dwarf, elf, engineer, heavy, mage, medic, necro, ninja, pyro, scout, soldier, thief, vampire, mage2, random, classe, arqueiro, assassino, quimico, qumico, anao, ano, elfo, engenheiro, guerreiro, mago, medico, mdico, incendiario, incendirio, batedor, soldado, ladrao, ladro, vampiro, mago2, aleatorio]
118:   kits:
119:     description: Manage the classes, such as disabling and setting limits
120:     aliases: [classes, classmanager]
121:   kits summary:
122:     description: View current class controls
123:     usage: /<command>
124:     permission: mcctf.kits.summary
125:   kits disable:
126:     description: Disable a class so that no players can use it
127:     usage: /<command> <class>
128:     permission: mcctf.kits.disable
129:   kits enable:
130:     description: Enable a class so that players can use it
131:     usage: /<command> <class>
132:     permission: mcctf.kits.enable
133:   kits limit:
134:     description: Manage kit limits
135:     usage: /<command> <set | remove>
136:   kits limit set:
137:     description: Limit a class so that only a certain number of players can use it
138:     usage: /<command> <class | all> <limit>
139:     permission: mcctf.kits.limit
140:   kits limit remove:
141:     description: Remove a class limit so that anyone can use it
142:     usage: /<command> <class | all>
143:     permission: mcctf.kits.limit
144:   map:
145:     description: Manage maps
146:   map info:
147:     description: View the current map
148:     usage: /<command>
149:     permission: mcctf.map.info
150:   map override:
151:     description: Specify maps to be played on reboot
152:     usage: /<command> <map ids>
153:     permission: mcctf.map.override
154:   map next:
155:     description: Insert a new game with the given map after the current game
156:     usage: /<command> <map ids>
157:     permission: mcctf.map.next
158:   respawn:
159:     description: Respawn yourself immediately
160:     usage: /<command>
161:     permission: mcctf.respawn
162:   switch:
163:     description: Switch to the other team
164:     usage: /<command>
165:     permission: mcctf.switch
166:   timer:
167:     description: Manage the game timer
168:   timer set:
169:     description: Set the current time (in seconds) left on the timer
170:     usage: /<command> <seconds>
171:     permission: mcctf.timer.set
172:   timer lock:
173:     description: Lock the timer to prevent it from counting down
174:     permission: mcctf.timer.lock
175:   timer unlock:
176:     description: Unlock the timer to allow it to begin counting down
177:     permission: mcctf.timer.unlock
178:   timer skip:
179:     description: Advance the game as if the timer has immediately expired
180:     permission: mcctf.timer.skip
181:   yell:
182:     description: Yell!
183:     aliases: [a, all, g]
184:     permission: mcctf.yell
</file>

</files>
